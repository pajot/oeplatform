{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Developer documentation of the Open Energy Platform (OEP)","text":"<p>Welcome to the Open Energy Platform Documentation. This site provides the developer documentation for the Open Energy Platform (OEP).</p> <p>State of the documentation</p> <p>The documentation already provides helpful information but is not yet complete. As only parts of it were maintained during the long-term development, we have to catch up. This is a task that we cannot complete in one go. We have therefore decided to complete it step by step. This means that we will update the documentation of the missing code as soon as we have to work on the corresponding code again. Documentation for the Community area will be added continuously and in a timely manner.</p> <p>Compendium</p> <p>If you want to get an overview about the complete Open Energy Family Framework please have a look at our Compendium.</p>"},{"location":"#structure-of-the-documentation","title":"Structure of the documentation","text":"<p>It consists of two parts:</p> <ul> <li> <p>The \"Development\" pages provide an overview of our methods and procedures used during development and also provides context about the Open Energy Platform Software to be able to understand the Use Cases and the general scope better.</p> </li> <li> <p>The \"Installation &amp; Code Documentation\" pages will help you to install and set up the Open Energy Platform software system if you wish to use the software for your own purposes or contribute to its development. The \"Code Documentation\" section provides technical information relevant to understanding the infrastructure elements and architecture of the software. You will also find information about the structure of the oeplatform code project on GitHub. Of course, you will also find documentation about the code itself. This part is divided into two sections describing the web APIs provided by the platform and the documentation about the implemented functions. To structure this part, we group the code documentation according to the features that the code implements and we hope to create an easier understanding of the codebase with this structured approach.</p> </li> </ul>"},{"location":"#what-do-we-want-to-archive-with-the-oep-website","title":"What do we want to archive with the OEP-Website","text":"<p>The Open Energy Platform is a website that has three main targets:</p> <ol> <li>Provide a language-independent interface that is a thin layer on top of the Open Energy Database (oedb)</li> <li>Implement an intuitive and easy-to use web interface on top of the database</li> <li>Improve the visibility, communication, and transparency of results from energy system modeling</li> </ol>"},{"location":"#mission-statement","title":"Mission statement","text":"<p>The transition to renewable energy sources is one of the huge goals of the last few decades. Whilst conventional energy generation provides a constant, generally available source of electricity, heat, and so on, our environment pays a toll. Contrary, renewable energy generation is less environmentally demanding but more financially expensive or just locally or inconsistently available. Guaranteeing a steady and reliable, yet sustainable supply of energy requires still a lot of thorough research.</p> <p>Expansion of the energy grid might imply measures that must be communicable in a transparent way. Hence, results from research of energy system studies should be publicly available and reproducible. This raises the need for publicly available data sources.</p>"},{"location":"dev/","title":"Index","text":"<p>See our developer guidelines and get in touch with our developer team.</p>"},{"location":"dev/best-practice/","title":"Best practice","text":""},{"location":"dev/best-practice/#gitworfklow","title":"GitWorfklow","text":""},{"location":"dev/best-practice/#code-formatting","title":"Code Formatting","text":""},{"location":"dev/best-practice/#isort","title":"isort","text":""},{"location":"dev/best-practice/#flake8","title":"flake8","text":""},{"location":"dev/best-practice/#docstrings","title":"Docstrings","text":""},{"location":"dev/best-practice/#_1","title":"Best practice","text":""},{"location":"dev/community/","title":"Community","text":""},{"location":"dev/community/#collaboration","title":"Collaboration","text":"<p>Note</p> <p>Further information</p>"},{"location":"dev/git-github/","title":"Git &amp; GitHub","text":""},{"location":"dev/git-github/#github","title":"GitHub","text":""},{"location":"dev/git-github/#issues","title":"Issues","text":""},{"location":"dev/git-github/#pull-requests","title":"Pull Requests","text":""},{"location":"dev/collaboration/planning-communication/","title":"Planning &amp; Communication","text":""},{"location":"dev/collaboration/planning-communication/#communitcation","title":"Communitcation","text":""},{"location":"dev/collaboration/planning-communication/#chat","title":"Chat","text":""},{"location":"dev/collaboration/planning-communication/#meetings","title":"Meetings","text":""},{"location":"dev/collaboration/planning-communication/#project-planning-with-github","title":"Project-planning with GitHub","text":""},{"location":"dev/collaboration/planning-communication/#milestones","title":"Milestones","text":""},{"location":"dev/collaboration/planning-communication/#projects","title":"Projects","text":""},{"location":"dev/collaboration/planning-communication/#releases","title":"Releases","text":""},{"location":"install-and-documentation/","title":"Installation &amp; Code Documentation","text":"<p>The Installation section provides detailed information required to install the oeplatform software. In addition to the website, this includes various databases (see Infrastructure). You will also find information on which further setup steps should be carried out in order to start developing the oeplatform software.</p> <p>The Documentation section provides documentation about the code and is currently incomplete. We aim to provide a full documentation about our soft- and hardware Infrastructure. The code is documented for each feature that is actively implemented. While some features are missing in the documentation as it was not available or lost after the implementation we will constantly review the code an document the missing parts.</p> <p>Note</p> <p>We structure the document by providing information about the WEB-API\u00b4s and the code grouped by the Features it implements.</p>"},{"location":"install-and-documentation/install/development-setup/","title":"Development setup","text":"<p>See our developer guidelines and get in touch with our developer team. Have a look at the official git-Book instructions on how to setup your git on a new system to be able to contribute to our GitHub repository.</p>"},{"location":"install-and-documentation/install/development-setup/#choose-your-development-environment-and-tools","title":"Choose your development environment and tools","text":"<p>As a software developer, you learn your own way of working and refine it as your experience grows. The choice of developer environment &amp; tools is therefore largely a personal preference. Here we want to suggest how new developers can get started and how we can implement successful, efficient development.</p> <p>In addition, there are some tools that are absolutely necessary to ensure the quality of the software while new code from various sources is collaboratively fed into a code repository on github.</p>"},{"location":"install-and-documentation/install/development-setup/#the-operating-system","title":"The operating system","text":"<p>In our installation guide we offer the installation for all common OS (Linux/Apple, Windows). Since the server on which the developed software (especially web applications) is operated is usually a Linux-based system, it is also highly advisable to design the local development environment as similarly as possible.</p> <p>Especially for developers using a Windows computer, there are relevant considerations here to avoid constant additional work that is necessary to install certain packages in order to remain compatible with the latest developments.</p> <p>Those who want to participate in software development in the long term should therefore consider whether it is worth using either a container solution such as Docker in which the software and databases are installed. New code can then be written or tested directly in the container via an IDE. On the other hand, WSL has also been available for some time, which can be used to run a Linux system on a Windows computer. As Microsoft itself developed the solution, it is particularly well integrated.</p>"},{"location":"install-and-documentation/install/development-setup/#development-tools","title":"Development tools","text":"<p>We mainly use VSCode or PyCharm as an integrated development environment (IDE). These IDEs are particularly easy to install, can be flexibly extended with plugins and enable all relevant tools for development to be operated in one window, which in our view increases productivity.</p>"},{"location":"install-and-documentation/install/development-setup/#pre-commit-hooks","title":"pre-commit-hooks","text":"<p>We encourage you to install our pre-commit hooks. They will probably get in the way sometimes when you try to \"just commit\" your code, but they help us to ensure the quality of the code, especially the formatting of the code.</p> <pre><code>pip install pre-commit\n</code></pre> <p>And install our hooks as defined in the '.pre-commit-config.yaml' file</p> <pre><code>pre-commit install\n</code></pre> <p>From now on, you can only transfer if the hooks are successful.</p>"},{"location":"install-and-documentation/install/development-setup/#useful-vscode-plugins","title":"Useful VSCode plugins","text":"<p>You can search the name in the VSCode Extensions tab:</p> <ul> <li>Black Formatter</li> <li>isort</li> <li>Flake8</li> <li>Pylance</li> <li>Python</li> <li>Python Debugger</li> <li>Code Spell Checker</li> <li>Database Client</li> <li>ESLint</li> <li>markdownlint</li> <li>GitLens</li> </ul>"},{"location":"install-and-documentation/install/development-setup/#run-all-tests","title":"Run all tests","text":"<p>We aim to develop the oeplatform by using the test driven development approach. Fundamentally this requires a testing framework that is provided by django. If you want to check if your changes to the codebase affect the existing functionality run all available tests:</p> <pre><code>python manage.py test\n</code></pre> <p>Most of our current tests are available in the <code>api</code> app of the django project. Look for the <code>tests</code> directory in any of our apps.</p>"},{"location":"install-and-documentation/install/development-setup/#deploy-locally","title":"Deploy locally","text":"<p>You can run your own local copy of the OEP website server with</p> <pre><code>python manage.py runserver\n</code></pre> <p>By default, you should be able to connect to this copy by visiting localhost:8000 in your web browser. This way you can insert your changes without worrying about breaking anything in the production system.</p>"},{"location":"install-and-documentation/install/development-setup/#user-management-setup-a-test-user","title":"User Management - Setup a test user","text":"<p>To create a dummy user for functionality testing purposes</p> <p>Then execute this python code (either directly in a terminal or from a file)</p> <pre><code>import os\nimport django\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"oeplatform.settings\")\ndjango.setup()\nfrom login.models import myuser\nu = myuser.objects.create_devuser('test','test@mail.com')\nu.set_password('pass')\nu.save()\n</code></pre>"},{"location":"install-and-documentation/install/development-setup/#create-test-tables","title":"Create test tables","text":"<p>You have multiple options to create tables and upload data. We will not explain the approach using a SQL dump that is imported into the postgresql database. The easiest approach that will get you started quickly is based on the OEP-Website UI. The related functionality is part of the <code>dataedit</code> app in the django project.</p> <p>Before we can get started we have to register the topics where data can be grouped to. Initially all data is uploaded to the topic <code>model_draft</code>. Once it is published it is moved to another topic e.g. <code>demand</code> or <code>scenario</code>. You can use the management command to register our predefined topics:</p> <pre><code>python manage.py create_topics\n</code></pre>"},{"location":"install-and-documentation/install/development-setup/#using-the-http-api","title":"Using the HTTP-API","text":"<p>You can either use the http api that is available once you started your local development server using the <code>runserver</code> command. To understand how to use the api you can have a look at our academy courses but keep in mind that you have to modify the URL of the api endpoints to you locally running oep instance. You can to this by changing the beginning of the url from something like <code>https://www.oeplatform.org/</code> to <code>http://127.0.0.1/</code>. Have a look at this course to get started with the http api.</p>"},{"location":"install-and-documentation/install/development-setup/#using-the-oep-website-ui","title":"Using the OEP-Website UI","text":"<p>The OEP-Website includes a features that is called upload wizard internally. This features usually is used by the user to add datasets to the <code>model_draft</code> topic and can be accessed via the database page. Initially the database is empty and the topic cards are not visible. You have to navigate to the page manually. Once you have started your local instance of the OEP you can navigate to this URL:</p> <pre><code>http://127.0.0.1/dataedit/wizard/\n</code></pre> <p>There you can create a table, upload data from CSV file, create metadata and then navigate to the table page. To get started it is okay to just create a table with minimal requirements by just adding a table name that is all lowercase and does not include whitespaces, - or any special characters.</p>"},{"location":"install-and-documentation/install/development-setup/#publish-aka-move-datasets","title":"Publish aka move datasets","text":"<p>Once you created your test data you probably want to move your data to any of the other topics. This functionality is also available via the Website UI and by using another endpoint of the HTTP-API.</p>"},{"location":"install-and-documentation/install/development-setup/#via-the-http-api","title":"Via the HTTP-API","text":"<p>There is no tutorial available for this feature. You can send a post request to the following URL. You need to add your api token to the post request header. You can have a look on the table create tutorial linked above to understand how you can do that. In python you can use the package <code>requests</code> to perform http requests.</p> <pre><code>http://127.0.0.1/v0/schema/&lt;str:schema&gt;/tables/&lt;str:table&gt;/move/&lt;str:to_schema&gt;/\n</code></pre> <p>The URL must include the name of the topic and table you want to move and the name of the topic you want to move table to. In the future this endpoint will change because it is part of the publishing process. Moving a table will then only be possible once the metadata for that table includes an open data license.</p>"},{"location":"install-and-documentation/install/development-setup/#via-the-oep-website-ui","title":"Via the OEP-Website UI","text":"<p>You can navigate to the profile page using your local instance of the OEP website.</p> <pre><code>http://127.0.0.1/user/profile/\n</code></pre> <p>There you find a tab called tables. If you include an open data license in the metadata of your test table you previously create in the <code>model_draft</code> topic, a publish button becomes visible. Once you click it you can select a topic to move the table to.</p> <p>You can edit the metadata for a table by visiting the detail page of a table then click the tab meta information and click the button edit. The license information should be added to the licenses field of the metadata.</p>"},{"location":"install-and-documentation/install/installation/","title":"Install and setup the OpenEnergyPlatform Application","text":"<p>Below we describe the manual installation of the oeplatform code and infrastructure. The installation steps have been proofed on linux and windows for python 3.10.</p> <p>Tip</p> <p>We also offer the possibility to use docker, to install the oeplatform and additional databases. As the hole setup is pre-configured docker can be used to automatically install the hole infrastructure.</p> <p>We provide 2 docker container images (OEP-website and OEP-database). The images are updated &amp; published with each release. They can be pulled from GitHub packages.</p> <p>Here you can find instructions on how to install the docker images.</p> <p>Danger</p> <p>Currently the docker based installation does not cover the installation of the additional database <code>jenna-fuseki</code> a triple store that stores graph data used in some of our features.  It is not mandatory to run the core functionality of the oeplatform. You need to install it manually as described in the installation guide.</p> All steps &amp; commands in one list <p>This list of commands will only work on systems where the core system dependencies already exists. Please use the full installation guide in case you encounter errors.</p> <ol> <li> <p>Get code &amp; install dependencies.</p> <ul> <li><code>git clone https://github.com/OpenEnergyPlatform/oeplatform.git</code></li> <li><code>cd oeplatform</code></li> <li><code>python -m venv env</code></li> <li><code>source env/bin/activate</code></li> <li><code>pip install -r requirements.txt</code></li> </ul> </li> <li> <p>Setup the OEO integration</p> <ul> <li>Instructions on Section 4</li> <li>Automatically added in docker container</li> </ul> </li> <li> <p>Loading and compressing static assets</p> <ul> <li>Create your <code>securitysettings.py</code> config file from our default settings: Copy &amp; rename <code>oeplatform/securitysettings.py.default</code> &gt;  <code>securitysettings.py</code></li> <li><code>python manage.py collectstatic</code></li> <li><code>python manage.py compress</code></li> <li>These steps are automatically added in the docker container</li> </ul> </li> <li> <p>Install databases &amp; setup connection</p> <ul> <li>Chose option 1 to use docker to install PostgreSQL and most of the setup automatically. You need to install jenna-fuseki additionally as it is not part of the docker container.</li> <li>Chose 2 to install everything on your directly on your system.</li> </ul> Option 1: Use docker <ul> <li>Install docker</li> <li>while in oeplatform directory <code>cd docker</code></li> <li><code>docker compose -f docker-compose.yaml</code></li> <li>start docker container</li> <li>Additionally install and start jenna-fuseki db as docker or install it locally.</li> </ul> Option 2: Manual database setup <ul> <li>install manually</li> </ul> <p>Summary:</p> <ul> <li>Setup databases PostgreSQL, Jenna-Fuseki</li> <li>Install &amp; start Jenna-Fuseki and create datastore <code>OEKG_DS</code> via the web interface: http://127.0.0.1:3030/</li> <li>Install PostgreSQL</li> <li>Use db user <code>postgres</code> with password <code>postgres</code>:</li> <li>Create databases: <code>oep_django</code>, <code>oedb</code>: <code>sudo -u postgres psql</code></li> <li>Install postgresql extensions <code>hstore</code>, <code>postgis</code>, <code>postgis_topology</code>, <code>pg_trgm</code></li> <li>Setup the connection to the database server to the Django project by adding the credentials in the <code>oeplatoform/securitysettings.py</code></li> </ul> </li> <li> <p>Run management commands to complete the database setup</p> <ul> <li><code>python manage.py migrate</code></li> <li><code>python manage.py alembic upgrade head</code></li> </ul> Sept 3.1: Management commands: <p>These commands are most likely not relevant if you are setting up oeplatform for the first time. Use the following command to show a list of all available management commands.</p> <ul> <li><code>python manage.py -h</code></li> </ul> </li> <li> <p>Install react app</p> <ul> <li>Install node oder nvm on your system</li> <li>navigate into <code>factsheet/frontend</code> to install the scenario bundles</li> <li>navigate into the <code>oeo_viewer/client</code> to install the oeo viewer</li> <li>Run <code>npm install</code></li> <li>Navigate back <code>cd ../..</code> to oeplatform root</li> <li>Make sure the jenna-fuseki database is up and running locally</li> <li>Run management commands to install bot react apps<ul> <li><code>python manage.py build_factsheet_app</code></li> <li><code>python manage.py build_oeo_viewer</code></li> </ul> </li> <li>Update the served javaScript bundle files in templates:<ul> <li><code>factsheet/static/js/main###.js</code> -&gt; <code>factsheet/template/index.html</code></li> <li><code>oeo_viewer/static/js/main###.js</code> -&gt; <code>oeo_viewer/template/index.html</code></li> </ul> </li> </ul> </li> <li> <p>Deploy locally</p> <ul> <li> <p>Check if the all connected database servers are running.</p> <ul> <li>sudo service postgresql start</li> <li>in the directory where you installed</li> </ul> </li> <li> <p><code>python manage.py runserver</code></p> </li> <li> <p>Open Browser URL: 127.0.0.1:8000</p> </li> <li> <p>create a test user.</p> </li> </ul> </li> </ol>"},{"location":"install-and-documentation/install/installation/#0-prequisit","title":"0 Prequisit","text":"<p>The installation instructions mainly refer to the creation of a local instance of the oeplatform with a focus on the development or contribution to the software development on github. Before you start the installation look at this section and think about which operating system you want to use.</p> <p>Deploying the software on a server to make it publicly accessible via the Internet is a further step.</p>"},{"location":"install-and-documentation/install/installation/#notes-for-deployment","title":"Notes for deployment","text":"<p>We do not currently provide instructions for deployment. It also depends heavily on the server environment. In general, a web server (e.g. Apache) and a web server gateway for Python (e.g. mod_wsgi) are required to make the software available on the internet.</p>"},{"location":"install-and-documentation/install/installation/#1-setup-the-repository","title":"1 Setup the repository","text":"<p>Recommended: Create a directory to store the oeplatform code and additional resources.</p> <pre><code>mkdir oep-website\ncd oep-website\n</code></pre> <p>Clone the repository locally</p> <pre><code>git clone https://github.com/OpenEnergyPlatform/oeplatform.git\n</code></pre>"},{"location":"install-and-documentation/install/installation/#2-setup-virtual-environment","title":"2 Setup virtual environment","text":"<p>Navigate to the oeplatform directory you just cloned</p> <pre><code>cd oeplatform\n</code></pre> <p>Below we explain two methods to install the virtual environment for python.</p>"},{"location":"install-and-documentation/install/installation/#conda-on-windows","title":"Conda (on Windows)","text":"<p>If you are a Windows user, we recommend you use conda because of the dependency on the <code>shapely</code> package. It was causing installation issues that potentially have resolved. Don't forget to activate the environment after the setup is done.</p> <pre><code>conda env create -f environment.yml\nconda activate env\n</code></pre>"},{"location":"install-and-documentation/install/installation/#venv-on-linux-mac","title":"venv (on Linux / Mac)","text":"<p>If you are not using windows or don't want to use conda, here you can find instructions for setting up virtual environment. In short: You can also use Python to create the environment. Make sure you install the venv package for your python version. Don't forget to activate the environment.</p> <p>On linux you can use:</p> <pre><code>sudo apt install python3.xx-venv # change xx to your exact version\npython3 -m venv env\nsource env/bin/activate\n</code></pre>"},{"location":"install-and-documentation/install/installation/#install-requirements","title":"Install requirements","text":"<p>After you have activated your virtual environment, install the required python libraries</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"install-and-documentation/install/installation/#3-setup-the-openenergyontology-integration","title":"3 Setup the OpenEnergyOntology integration","text":""},{"location":"install-and-documentation/install/installation/#31-include-the-full-oeo","title":"3.1 Include the full oeo","text":"<p>It is necessary to include the source files of the OpenEnergyOntology (OEO) in this project. The goal is to have a new directory like you see below inside the oeplatform directory. The new folder should be stored alongside the django apps and other code related files.</p> <pre><code>```bash\nontologies/\n\u2514\u2500\u2500 oeo\n    \u2514\u2500\u2500 1.0.0 # in production this will be the version of a specific OEO release\n        \u251c\u2500\u2500 imports\n        \u251c\u2500\u2500 modules\n        \u2514\u2500\u2500 oeo-full.owl\n```\n</code></pre> <p>The directory where all ontologies are stored is called \"ontologies\". If you want to change the name of the directory you have to update the settings.py file for the oeplatform also. The following variables are relevant for the configuration of the ontology integration. In most cases, you can use the default settings.</p> <pre><code>ONTOLOGY_FOLDER # Name of the folder for all ontologies\nONTOLOGY_ROOT   # constructed Path for all ontologies\nOPEN_ENERGY_ONTOLOGY_NAME   # Name of the oeo\nOPEN_ENERGY_ONTOLOGY_FOLDER # constructed Path for the oeo directory\n</code></pre> <p>If you use the default naming \"ontologies\" you should create this directory. Then you can download the full oeo release from GitHub and unzip them into the new directory. To validate you can check whether you can find the file \"oeo-full.owl\". Please ensure, that you get the structure shown above.</p>"},{"location":"install-and-documentation/install/installation/#4-loading-and-compressing-static-assets-from-the-oeplattform-applications","title":"4 Loading and compressing static assets from the Oeplattform applications","text":"<p>Static data is often stored in the django apps and various additional scripts are loaded, e.g. in HTML files. To enable django to access these resources more efficiently, various management commands are used to collect and partially compress the relevant files.</p> <p>To be able to run the commands below we first need to Setup the security settings file for local development. This file is specific to your local settings. In production environment it is used to store / retrieve critical information that must not be pushed to any publicly available source control system like GitHub.</p> <ul> <li>Navigate to <code>oeplatform/oeplatform</code></li> <li>copy the file <code>securitysettings.py.default</code> and rename it to <code>securitysettings.py</code></li> </ul> How to configure securitysettings.py <p>The security settings provide information to django to connect to your databases, relevant for step 5, below. You can provide the access credentials directly in the script or import them using environment variables. For detailed instructions see section 3. of the manual database setup guide.</p> <p>After the above setup is done make sure the python environment is activated and then run:</p> <pre><code>python manage.py collectstatic\npython manage.py compress\n</code></pre>"},{"location":"install-and-documentation/install/installation/#5-databases-setup","title":"5 Databases setup","text":"<p>We use two relational databases to store the oeplatform data:</p> <ul> <li>The oep-django database is our internal database. It is used to store the django application related data. This includes things like user information, reviews, table names, ...</li> <li>Our primary database is the OEDB (Open Energy Database). It is used to store all data the user uploaded. In production it stores multiple terabyte of data.</li> </ul> <p>Additional we use a triple store database:</p> <ul> <li>Store the open energy ontologies and open energy knowledge graph</li> <li>For now this is not part of the installation guide as it is not mandatory to run the oeplatform and can be added later.</li> </ul>"},{"location":"install-and-documentation/install/installation/#51-how-to-install-the-databases","title":"5.1 How to install the databases","text":"<p>You have two options to install the database:</p>"},{"location":"install-and-documentation/install/installation/#a-install-the-database-manually","title":"a) Install the database manually","text":"<ul> <li>You chose to install the databases manually by installing PostgreSQL &amp; jenna-fuseki and complete the setup. In this case you can follow our manual database setup guide.</li> <li>Using this option you will install the jenna-fuseki &amp; postgresql databases on your local system. You need to start both databases manually before you can start using them for development.</li> </ul>"},{"location":"install-and-documentation/install/installation/#b-use-our-docker-image","title":"b) Use our docker image","text":"<ul> <li>You can also use our docker based installation to install a container which will automatically setup the two databases. You still have to install docker on your system. Here you can find instructions on how to install the docker images.</li> <li>The jenna-fuseki triple store is not part of the docker image so far. You would either have to setup the public docker image here and adjust the credentials in the <code>securitysettings.py</code> or you can perform the steps explained in Section 1.2 of the manual database setup to install the jenna-fuseki database on your system. You will have to start the service manually afterwards.</li> </ul>"},{"location":"install-and-documentation/install/installation/#52-create-the-database-table-structures","title":"5.2 Create the database table structures","text":"<p>Before you can start development, you need to setup tables in the two PostgreSQL databases. To do this, you can run two management commands. The django command will set up all structures required by the oep system in the oep_django database and the alembic command will create all the structures in the OEDB. These structures define how large amounts of uploaded user data is stored in the database. On a high level this is similar to partitions on you personal computer. This structure help's the developers and the system to find the data and group data together.</p> <p>First verify that your database service is running. In case you are using docker start the container. If you installed postgresql locally start the service. On Linux you can use the following command in the terminal:</p> <pre><code>sudo service postgresql start\n</code></pre>"},{"location":"install-and-documentation/install/installation/#521-django-setup-oep_django","title":"5.2.1 Django setup - oep_django","text":"<p>In order to run the OEP website, the django database needs some extra management tables. We use the django specific migrations. Each django app defines it own migrations that keep track of all changes made to any app related tabes. The table structure itself is defined as an abstraction in the models.py for each django app.</p> <pre><code>python manage.py migrate\n</code></pre>"},{"location":"install-and-documentation/install/installation/#522-alembic-setup-oedb","title":"5.2.2 Alembic setup - oedb","text":"<p>In order to run the OEP website, the primary database needs some extra management tables. We use <code>alembic</code> to keep track of changes to the general structure of the primary database and its initial state e.g. what tables should be there and more. To create all tables that are needed, simply type:</p> <pre><code>python manage.py alembic upgrade head\n</code></pre> <p>Note</p> <p>If you encounter errors in this step verify that your database service is available, the databases <code>oep_django</code> and <code>oedb</code> exist and your <code>securitysettings.py</code> provide the correct access credentials.</p>"},{"location":"install-and-documentation/install/installation/#6-install-the-openenergyontology-tools","title":"6 Install the OpenEnergyOntology tools","text":"<p>Only start the following steps if you have completed step 3 above.</p>"},{"location":"install-and-documentation/install/installation/#61-setup-the-oeo-viewer-app","title":"6.1 Setup the OEO-viewer app","text":"<p>Optional Step</p> <p>This step is not mandatory to run the oeplatform-core as it is a plug able React-App. If you don't include this step you can access the oeplatform website including most ontology pages except for the oeo-viewer.</p> <p>The oeo-viewer is a visualization tool for our OEO ontology and it is under development. To be able to see and use the oeo-viewer as part of the oep-website, follow the steps below:</p> <ol> <li>Install npm:    To install npm it is suggested to use the node version manager.<ul> <li>On Linux &amp; Mac:  Node Version Manager (nvm)</li> <li>On Windows: NVM for Windows.</li> <li>Install node version 18</li> </ul> </li> <li> <p>Get the ontology files (see Section 3)</p> </li> <li> <p>Build the oeo-viewer:     <pre><code>cd oep-website/oeplatform/oeo_viewer/client\nnpm install\nnpm run build\n</code></pre></p> </li> </ol> <p>After these steps, a <code>static</code> folder inside <code>oep-website/oeplatform/oeo_viewer/</code> will be created which includes the results of the <code>npm run build</code> command. These files are necessary for the oeo-viewer.</p>"},{"location":"install-and-documentation/install/installation/#7-setup-the-scenario-bundles-app","title":"7 Setup the Scenario-Bundles app","text":"<p>Optional Step</p> <p>This step is not mandatory to run the oeplatform-core as it is a plug able React-App. If you don't include this step you can access the oeplatform website except scenario-bundle pages including the scenario-comparison React modules.</p> <p>In the django app directory <code>oeplatform/factsheet</code> we provide a Web-API to access the OEKG and the Scenario-Bundle feature. Similar to the oeo-viewer we need to use npm to install &amp; build the Scenario-Bundle app and integrate the build in the django app.</p> <ol> <li>Make sure npm is installed.</li> <li> <p>Start the jenna-fuseki database (see instructions from the installation).    The connection to the database API is setup in the factsheet/views.py you have to make sure that you provide the correct URL to you database instance. In development mode it should be something like:    <pre><code>query_endpoint = 'http://localhost:3030/ds/query'\nupdate_endpoint = 'http://localhost:3030/ds/update'\n</code></pre></p> </li> <li> <p>Configure the React app</p> <p>To be able to construct the API URLS that are necessary for communication between the react frontend and the django backend in the react code we have to configure the URL where our django application is available. In development mode this should be http://127.0.0.1:8000/, so add the line <code>\"toep\": \"http://127.0.0.1:8000/\"</code> to <code>factsheet/frontend/src/conf.json</code>.</p> </li> <li> <p>Build the scenario bundle app:       <pre><code>cd factsheet/frontend\nnpm install\ncd ../..\n# Use the django management command\npython manage.py build_factsheet_app\n</code></pre></p> </li> <li> <p>Serve the React build on a django website  </p> <p>To serve the React build on a website that is provided by django you have to include the build files from the <code>factsheet/static</code> directory in the django template in <code>factsheet/templates/index.html</code>. In the HTML-template you must make sure that the JavaScript bundle file is imported. The name of the file changes after each new build and it should read like <code>main.5654a0e0.js</code>.</p> <p>The template should then include this line:</p> <pre><code>&lt;script src=\"{% static 'factsheet/js/main.55586e26.js' %}\"&gt;&lt;/script&gt;\n</code></pre> </li> </ol>"},{"location":"install-and-documentation/install/installation/#next-steps","title":"Next steps","text":"<p>Have a look at the steps described in the Development &amp; Collaboration section.</p>"},{"location":"install-and-documentation/install/manual-db-setup/","title":"Complete manual database setup","text":"<p>Below we describe the complete manual installation of the OpenEnergyPlatform database infrastructure, which is currently composed by multiple databases:</p> <ol> <li> <p>PostgreSQL</p> </li> <li> <p>Internal django database (oep_django)</p> </li> <li> <p>as well as the primay database OpenEnergyDatabase (oedb)</p> </li> <li> <p>Apache Jena Fuseki</p> </li> <li>and a SPARQL server for the OEKG</li> <li>requires java</li> </ol>"},{"location":"install-and-documentation/install/manual-db-setup/#1-install-the-database-infrastructure","title":"1 Install the database infrastructure","text":"<p>To setup the PostgreSQL database on your own machine you have to install the database software and setup additional packages. After the databases are installed you have to create the database tables that are already available as data model in the oeplatform code project. There we maintain the tables as python classes called models. You will use django and alembic to create these table automatically.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#11-install-postgresql","title":"1.1 Install postgresql","text":"<p>If postgresql is not installed yet on your computer, you can follow this guide.</p> <p>Using linux it is most likely already installed. But you can use the following command to install it.</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install postgresql\n</code></pre> <p>During the installation, make sure that you note the superuser and password. Other relevant details are the host and the port, these will most likely be set to the default value. In the oeplatoform default configuration the values are:</p> <ul> <li>Host <code>127.0.0.1</code> or <code>localhost</code>.</li> <li>Port <code>5432</code></li> </ul> <p>For the creation of spatial objects we use the PostGIS plugin for PostgreSQL. On linux you can use:</p> <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install postgresql-14-postgis-3\n\n# might be relevant in some cases:\n# sudo apt-get install bin utils libproj-dev gdal-bin\n</code></pre> How to get PostGIS <p>PostGIS is a plugin for PostgreSQL and must be installed additionally. If you use an installation wizard, this step is probably included in the general PostgreSQL installation.</p> <pre><code>- On Windows, We recommend installing the postgis for your local PostgreSQL installation from [Application Stack Builder](https://www.enterprisedb.com/edb-docs/d/postgresql/installation-getting-started/installation-guide-installers/9.6/PostgreSQL_Installation_Guide.1.09.html) under `Spatial Extensions`. There should automatically be an entry for `PostGIS bundle ...` based on the installed version of PostgreSQL, please make sure it is checked and click next. The stack builder will then continue to download and install PostGIS. Alternately PostGIS can also be downloaded from [this official ftp server](http://ftp.postgresql.org/pub/postgis/) by PostgreSQL. Proceed to install the package. (Flag it as safe in the downloads if prompted, and select Run anyway from the Windows SmartScreen Application Blocked Window)\n\n- On Linux/Unix based systems the installation could be specific to the package manager being employed and the operating system, so please refer to the official installation instructions [here](https://postgis.net/install/). The section `Binary Installers` covers the installation instructions for various operating systems.\n</code></pre> <p>After the installation completed you can start the service. On linux you can simply run:</p> <pre><code>sudo service postgresql start\n</code></pre>"},{"location":"install-and-documentation/install/manual-db-setup/#12-install-apache-jena-fuseki","title":"1.2 Install Apache Jena Fuseki","text":"<p>!!! note - Skip the installation if your development task is not aimed at the OEKG. - For more information about Apache Jena Fuseki please visit this page. - Note that java is required to run the software</p> <ol> <li>Download apache-jena-fuseki-4.2.0.tar.gz     (for other versions please check here)</li> <li>Create a new directory on your system where you install oeplatform infrastructure components e.g. <code>~/oep-infra/</code> as alternative you can use the jenna-fuseki db via docker container. In this case you need to specify the correct credentails for that container in the <code>securitysettings.py</code> (See Step 3.)</li> <li> <p>Extract the downloaded file to the new directory e.g.:</p> <pre><code>tar -zxvf apache-jena-fuseki-4.2.0.tar.gz -C ~/oep-infra/\n</code></pre> </li> <li> <p>Navigate to the directory where the files are extracted and execute the following command to start the server:</p> <pre><code>./fuseki-server\n</code></pre> </li> <li> <p>To access the server UI, enter <code>http://localhost:3030/</code> in your web browser.</p> </li> <li>First click the manage datasets tab and then choose the add new dataset.</li> <li>Enter <code>OEKG_DS</code> for the dataset name and choose the type of dataset (in-memory datasets do not persist if the server stops) and click create dataset.</li> </ol>"},{"location":"install-and-documentation/install/manual-db-setup/#2-create-the-postgresql-databases","title":"2 Create the PostgreSQL databases","text":"<p>As you dont have to setup the graph databse to run most parts of the oeplatform application and the PostgreSQL databases are mandatory for the core functionality of the oeplatform we start to setup the oep_django and oedb databases on our local PostgreSQL server.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#21-django-internal-database","title":"2.1 Django internal database","text":""},{"location":"install-and-documentation/install/manual-db-setup/#211-posgresql-command-line-setup","title":"2.1.1 Posgresql command line setup","text":"<p>Once logged into your psql session from your terminal</p> <ul> <li>for linux: <code>sudo -u postgres psql</code></li> <li>for windows: <code>psql</code></li> </ul> <p>then run the following lines to first set the database password as it will ease the further steps:</p> <pre><code>ALTER USER postgres WITH PASSWORD 'postgres';\n</code></pre> <p>and then create the database:</p> <pre><code># optional: .. with owner = postgres;\ncreate database oep_django;\n</code></pre>"},{"location":"install-and-documentation/install/manual-db-setup/#22-primary-database","title":"2.2 Primary Database","text":"<p>This database is used for the data input functionality implemented in <code>dataedit/</code>.</p> <p>If this is your first local setup of the OEP website, this database should be an empty database as it will be instantiated by automated scripts later on.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#221-posgresql-command-line-setup","title":"2.2.1 Posgresql command line setup","text":"<p>Once logged into your psql session from your terminal</p> <ul> <li>for linux: <code>sudo -u postgres psql</code></li> <li>for windows: <code>psql</code></li> </ul> <p>Then you run the following lines to create the primary database:</p> <pre><code># optional: .. with owner = postgres;\ncreate database oedb;\n</code></pre>"},{"location":"install-and-documentation/install/manual-db-setup/#23-install-database-extensions-on-both-databases","title":"2.3 Install database extensions on both databases","text":"<p>After successfully installing PostGIS (see step 1.1), add the database extensions. We keep both database setups equal please enter the commands to both databases.</p> <p>Make sure you connect to psql</p> <pre><code>for linux: `sudo -u postgres psql`\nfor windows: `psql`\n</code></pre> <p><code>oedb</code> (<code>\\c oedb;</code>) then create extensions.</p> <p><code>oep_django</code> (<code>\\c oep_django;</code>) then create extensions also here.</p> <p>After you connected type the commands below and repeat for both of the databases:</p> <pre><code>CREATE EXTENSION IF NOT EXISTS postgis;\nCREATE EXTENSION IF NOT EXISTS postgis_topology;\nCREATE EXTENSION IF NOT EXISTS hstore;\n# This extension enable search for similar objects (e.g. by name)\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n</code></pre> <p>The database installation is now complete and you can exit the psql command line by typing:</p> <pre><code>\\q\n</code></pre>"},{"location":"install-and-documentation/install/manual-db-setup/#3-connect-database-to-the-django-project","title":"3 Connect database to the Django project","text":"<p>In the oeplatform repository, copy the file <code>oeplatform/securitysettings.py.default</code> and rename it <code>oeplatform/securitysettings.py</code>. Then, enter the connection to your above mentioned postgresql database.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#31-store-and-access-database-credentials","title":"3.1 Store and access database credentials","text":"<p>To setup the connection in the oeplatform project you can either setup environment variables that store the database connection credentials locally on your system or you can change the default value in the securitysetting. For production systems it is recommended to use the concept of environment variables.</p> <p>Note</p> <p>You have to provide the user name and password (with access to the oep_django and oedb database). Additionally you can configure the database name and the host and port variables if you don't run the database server using the default values.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#311-oep_django-internal-database","title":"3.1.1 oep_django internal database","text":"<p>In the oeplatform/securitysettings.py file enter the database connection details in this section:</p> <p>Info</p> <p>This code will attempt to collect the value from a environment variable in case it is not available the fallback value is used.</p> <pre><code>`'NAME': os.environ.get(\"OEP_DJANGO_NAME\", \"oep_django\")`\n</code></pre> <pre><code># oeplatform/securitysettings.py\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql_psycopg2',\n        'NAME': os.environ.get(\"OEP_DJANGO_NAME\", \"oep_django\"),\n     'USER': os.environ.get(\"OEP_DJANGO_USER\", \"postgres\"),\n     'PASSWORD': os.environ.get(\"OEP_DJANGO_PW\", \"postgres\"),\n     'HOST': os.environ.get(\"OEP_DJANGO_HOST\", \"localhost\")\n }\n}\n</code></pre> Setup environment variables <p>Create environment variables <code>OEP_DJANGO_USER</code> and <code>OEP_DJANGO_PW</code> with values <code>oep_django_user</code> and <code>&lt;oep_django_password&gt;</code>, respectively.</p> <pre><code>| environment variable | required |\n| -------------------- | -------- |\n| OEP_DJANGO_USER      | yes      |\n| OEP_DJANGO_PW        | yes      |\n| OEP_DJANGO_HOST      | no       |\n| OEP_DJANGO_NAME      | no       |\n\nFor default settings, you can type the following commands\n\n- On windows\nWe recommend you set the environment variables [via menus](https://www.computerhope.com/issues/ch000549.htm). However, we still provide you with the terminal commands (before you can set environment variables in your terminal you should first type `cmd/v`).\n\n    ```bash\n    set OEP_DJANGO_USER=oep_django_user\n    set OEP_DJANGO_PW=&lt;oep_django_password&gt;\n    ```\n\nIn the following steps we'll provide the terminal commands but you always can set the environment variables via menus instead.\n\n- On linux\n\n    ```bash\n    export OEP_DJANGO_USER=oep_django_user\n    export OEP_DJANGO_PW=&lt;oep_django_password&gt;\n    ```\n</code></pre>"},{"location":"install-and-documentation/install/manual-db-setup/#312-oedb-primary-database","title":"3.1.2 oedb primary database","text":"<p>In the oeplatform/securitysettings.py file enter the database connection details in this section:</p> <pre><code># oeplatform/securitysettings.py\n\ndbuser = os.environ.get(\"LOCAL_DB_USER\", \"postgres\")\ndbpasswd = os.environ.get(\"LOCAL_DB_PASSWORD\", \"postgres\")\ndbport = os.environ.get(\"LOCAL_DB_PORT\", 5432)\ndbhost = os.environ.get(\"LOCAL_DB_HOST\", \"localhost\")\ndbname = os.environ.get(\"LOCAL_DB_NAME\", \"oedb\")\n</code></pre> Setup environment variables environment variable required LOCAL_DB_USER yes LOCAL_DB_PASSWORD yes LOCAL_DB_PORT no LOCAL_DB_HOST no LOCAL_DB_NAME no <p>Make sure to set the required environment variables before going to the next section!</p> <p>For default settings, you can type the following commands</p> <ul> <li> <p>On windows</p> <pre><code>set LOCAL_DB_USER=oedb_user\nset LOCAL_DB_PASSWORD=&lt;oedb_password&gt;\nset LOCAL_DB_NAME=oedb\n</code></pre> </li> <li> <p>On linux</p> <pre><code>export LOCAL_DB_USER=oedb_user\nexport LOCAL_DB_PASSWORD=&lt;oedb_password&gt;\nexport LOCAL_DB_NAME=oedb\n</code></pre> </li> </ul> <p>Tip</p> <p>If you kept the default name from the above example in 2.1, then the environment variables <code>LOCAL_DB_USER</code> and <code>LOCAL_DB_NAME</code> should have the values <code>oedb_user</code> and <code>oedb</code>, respectively.</p>"},{"location":"install-and-documentation/install/manual-db-setup/#4-create-the-database-tables","title":"4 Create the database tables","text":"<p>To complete the database installation, the table structures must then be installed. Step 3 &amp; Step 4 must be completed first so that the necessary commands can be executed after.</p> <p>After that Proceed with the next steps in section 4.2 Create the database table structures of the oeplatform installation guide.</p>"},{"location":"install-and-documentation/oeplatform-code/architecture/","title":"Architecture","text":"<p>This section provides the necessary information to gain a basic technical understanding of the oeplatform software system, in particular the physical scheme of the hardware and software distribution, all modules of the software and the code project structure.</p> <p>Visit Infrastructure to lean about how we describe out hardware and software modules, the distribution and general interfaces that are implemented to drive the oeplatform software.</p> <p>Read oeplatform Modules and Software Project to learn about how we organize the code and project tools to enable our software development practice. This overview can be used if you want to start getting involved in the oeplatform development on GitHub.</p>"},{"location":"install-and-documentation/oeplatform-code/architecture/infrastructure/","title":"Infrastructure","text":"<p>The diagram shows the software architecture of openenergyplatform.org.</p> <p>In summary, the architecture is made up of various technologies that are installed on several servers.The individual servers each take on a specific responsibility in order to guarantee the functional scope of the open energy platform. As shown, the individual elements communicate via defined interfaces either via the internet (http) or in the internal network (TCP/IP).</p> <p>Basically, the openenergyplatform is a monolithic application as the functional core is developed together in a code base for frontend and backend. The application logic, database structure, web APIs and user interface are thus provided in the production system.</p> <p>In the course of development, more modern architectures were introduced, which are shown as services in the illustration. The LOEP service performs a specific task for which a user sends data to the service interface. The service has its own backend that processes the data and returns a suitable response. This architecture makes the system more modular.</p> <p>The database layer is always close to the applications and provides fast data access for the application via the internal network. In addition to application data such as user accounts, which are stored in the OEP Django database, there is the OEDB, which manages large amounts of data uploaded by users. The OEKB serves as a database for storing complex data. This involves data that has many attributes and relationships and is stored in the form of data triples. This enables high-performance and complex semantic data queries.</p> <p>The entire productive system and the databases are replicated in a test environment. Here, new versions of the software are installed before the official release and can be tested under real conditions.</p> <p>Note</p> <p>LOEP-Service is currently not included in the installation instructions.</p> <p></p>"},{"location":"install-and-documentation/oeplatform-code/architecture/infrastructure/#technologies","title":"Technologies","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/modules/","title":"Modules of the oeplatform software","text":"<p>This section describes the modules of the oeplatoform website software. As we use django modules are also called apps. Each modules describes a django app that provides all the backend functionality as well as the user interface for a specific area of the website.</p>"},{"location":"install-and-documentation/oeplatform-code/architecture/modules/#overview","title":"Overview","text":"<p>Each module represents a Django App and includes a specific functionality or area of the Open Energy Platform Website.</p> Module Function oeplatform - Configuration of the Django application- Security-critical configuration such as connection data to a database base - Basic structure for homepage and views in other components- Mainly static content for textual description of OEP and research projects- Contact form- Legal information api - Provision of the RESTful API- Data management- Generic and specific data queries using query parameters- User permission querying login - User management- Login system dataedit - Presentation of database contents- Metadata management and annotation of ontology terms- Data management via user interface- Tag system- Data visualization- Data querying via user interface- Open Peer Review for data modelview - Creation and editing of various factsheets using a developed standard format in the form of a form- Factsheet searching- Tag system ontology - Integration of the Open Energy Ontology- Presentation of the contents of OEO- Descriptive contents about OEO and the development process oeo_viewer - Open Energy Ontology visualization- Open Energy Ontology search functionality- Special feature: Integrated React application <p>In addition to Django apps, there are other components that serve specific functionalities within the system:</p> Module Explanation theming Configures the global design using Bootstrap5 and provides design components that are imported into the software components listed above. This is where the user-friendly and aesthetic presentation of the web application is configured. oedb_datamodels Implements database migration schemas used for migrating changes to the database (OEDB). These schemas are utilized by an imported software tool to manage all changes to the Open Energy Database from within the Django application."},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/","title":"Software Project","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#project-directory","title":"Project directory","text":"<p>The tree structure you see below describes the structure of the oeplatform code project. In general it is a django (using version 3.2) project that maintains multiple django apps that either serve for the frontend UI of the oeplatform website or host our WEB-API\u00b4s like the REST-API or our OEKG-API which provide a interface to specific functionality that accesses the the different databases we maintain.</p> <p>The tree also shows several configurations and text files for the django application itself and also the project tooling and management we use to operate, test, maintain and document the system as well as the software code. Some files are also used to provide specific information about the development and deployment process and some other files are used for the project presentation on GitHub.</p> <p>In the following we will dive a bit deeper into the structure of the project. We aim to provide a general understanding of the different modules so that developers become enabled to get started with the development.</p> <pre><code>.oeplatform\n\u251c\u2500\u2500 .github         # GitHub test automation &amp; repository configuration\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 api             # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 base            # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 dataedit        # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 docker          # Docker &amp; docker-compose setup\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 docs            # mkdocs based project &amp; code documentation\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 factsheet       # Django app with react frontend\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 login           # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 media           # All kinds of media data from app\u00b4s\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 modelview       # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 oedb_datamodels # Alembic migrations to manage the database structure\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 oeo_viewer      # Django app with react frontend\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 oeplatform      # Project configuration\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 ontology        # Django app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 static          # statics from all apps are collected here\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CACHE\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 theming         # The general oep design / styling and ui components\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 versions        # Changelogs\n\u2502   \u251c\u2500\u2500 bumpversion.sh\n\u2502   \u2514\u2500\u2500 changelogs\n\u251c\u2500\u2500 CITATION.cff\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 RELEASE_PROCEDURE.md\n\u251c\u2500\u2500 VERSION\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 tox.ini\n\u251c\u2500\u2500 manage.py\n\u251c\u2500\u2500 environment.yml\n\u251c\u2500\u2500 requirements-dev.txt\n\u251c\u2500\u2500 requirements-docs.txt\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#oeplatform","title":"oeplatform","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#django-apps","title":"Django Apps","text":"<p>Casual django app</p> <pre><code>\u251c\u2500\u2500 dataedit\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 admin.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 apps.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 forms.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 helper.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 management\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metadata\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 models.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 static\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 structures.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 templatetags\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 tests.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 urls.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views.py\n</code></pre> <p>Django app that integrates a react frontend</p> <pre><code>\u251c\u2500\u2500 factsheet\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 frontend\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 management\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 migrations\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 models.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 static\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 templates\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 urls.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views.py\n</code></pre> <p>Basic functionality</p> <ul> <li>base</li> <li>login</li> </ul> <p>REST API and Advanced API</p> <ul> <li>api</li> </ul> <p>Features</p> <p>Data publication(upload tabular data &amp; metadata), view, search, peer-review, download</p> <ul> <li>dataedit</li> </ul> <p>Model and Framework factsheets</p> <ul> <li>modelview</li> </ul> <p>Scenario Bundles &amp; Scenario Comparison</p> <ul> <li>factsheet</li> </ul> <p>Integration of the OpenEnergyOntology (view, search download full .owl file that includes the latest release of the oeo)</p> <ul> <li>ontology</li> </ul>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#design","title":"Design","text":"<ul> <li>base</li> <li>theming</li> <li>oep design system and workflow</li> </ul> <pre><code>\u251c\u2500\u2500 theming\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 _variables.scss\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 buildTheme.sh\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 oepstrap.scss\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 scss\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#django-project-configuration","title":"Django-Project configuration","text":"<pre><code>\u251c\u2500\u2500 oeplatform\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dumper.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 securitysettings.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 securitysettings.py.default\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 settings.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 urls.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 views.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 wsgi.py\n</code></pre> <ul> <li>django models &amp; migrations</li> <li>sqlalchemy alembic structures</li> </ul>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#oedatabase","title":"oedatabase","text":"<pre><code>\u251c\u2500\u2500 oedb_datamodels\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 README\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 env.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 script.py.mako\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 versions\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#oep-django-db","title":"oep django db","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#oe-knowledgegraph","title":"oe knowledgegraph","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#oe-knowledgebase","title":"oe knowledgebase","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#lookup-oep","title":"lookup oep","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#test-oeplatform-replication","title":"test oeplatform (replication)","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#dev-opperations","title":"Dev-opperations","text":"<ul> <li>github actions</li> <li>automated tests</li> <li>workflows and procedure</li> <li>requirement management</li> <li>versions</li> </ul>"},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#collaboration","title":"Collaboration","text":""},{"location":"install-and-documentation/oeplatform-code/architecture/project-structure/#documentation","title":"Documentation","text":"<pre><code>\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 css\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dev\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 index.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 install-and-documentation\n</code></pre> <pre><code>\u251c\u2500\u2500 docker\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 USAGE.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 apache2.conf\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 docker-compose.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 docker-entrypoint.sh\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/","title":"OpenEnergyPlatform features","text":"<p>This section provides detailed code documentation to document the implementation of all features of the oeplatform. In the Architecture/Modules section, we have already provided a brief overview of all the software modules (Django apps) that we maintain in the oeplatform.</p>"},{"location":"install-and-documentation/oeplatform-code/features/metaBuilder/","title":"metaBuilder","text":"<p>The metaBuilder is a tool to create, edit and download metadata for the oeplatform.</p>"},{"location":"install-and-documentation/oeplatform-code/features/metaBuilder/#create","title":"Create","text":""},{"location":"install-and-documentation/oeplatform-code/features/metaBuilder/#download","title":"Download","text":"<p>We currently offer multiple download buttons on the OEP. You can either download the metadata while editing the metadata on a table or when you use the standalone version of the metaBuilder. It is also possible to download the metadata when you view the metadata on a table in the \"meta information\" tab.</p> <p>When you download the metadata json file the empty fields are kept as \"null\" values.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/","title":"Developer documentation of the Open Peer Review Process","text":""},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#what-is-this-feature-about","title":"What is this feature about?","text":"<p>The Open Peer Review Process system facilitates collaborative review and validation of metadata through user interaction. It includes functionalities for uploading metadata, suggesting corrections, and reaching consensus on metadata fields. The system also features badge assignment and metadata updating upon agreement.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#who-will-use-it-what-are-the-use-cases","title":"Who will use it &amp; What are the use cases?","text":"<ol> <li>Metadata Authors: Users who upload metadata for review, interact with reviewers to address suggestions, and make necessary adjustments.</li> <li>Reviewers: Users who evaluate metadata fields, propose corrections, and collaborate with authors to reach agreement.</li> <li>Accompanying Persons: Users with extended rights to access and manage reviews, potentially overseeing the review process.</li> </ol>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#use-cases-include","title":"Use Cases include","text":"<ol> <li>Collaborative metadata validation and improvement.</li> <li>Badge assignment based on field agreement.</li> <li>Management and oversight of the review process.</li> </ol>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#what-functionality-is-there-from-a-user-pov-not-technical","title":"What functionality is there (from a user POV, not technical)?","text":"<ol> <li>Metadata Uploading and Reviewing: Users can upload metadata, propose corrections, and accept or deny fields.</li> <li>Interactive Feedback: Authors and reviewers interact to agree on metadata fields.</li> <li>Badge Assignment and Metadata Updating: Upon agreement, the appropriate badge is assigned, and metadata is updated.</li> <li>Review Management: Accompanying persons have special tools for review oversight.</li> </ol>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#description-of-the-review-process-for-users","title":"Description of the Review Process for Users","text":"<ol> <li>Uploading Metadata:</li> </ol> <p>Any registered user can upload metadata to the database page in the model_draft schema.</p> <ol> <li>Review Process:</li> </ol> <p>Other users, who are not the authors of the metadata, can review each field of the metadata. The reviewer has three possible actions:</p> <ul> <li>Accept: Agreeing with the current data of the field</li> <li>Suggest: Proposing corrections for the field</li> <li> <p>Deny: Rejecting, if the field does not meet the criteria or is not appropriate in content</p> </li> <li> <p>Author\u2019s Feedback:</p> </li> </ul> <p>The author of the metadata can view the reviewers' feedback on their page and respond to it, either agreeing with the suggestions or proposing their own changes.</p> <ol> <li>Interaction and Agreement:</li> </ol> <p>The reviewer and the author continue interacting until an agreement is reached and all fields obtain the accept status. A response can only be sent after evaluating all fields that do not yet have the accept status.</p> <ol> <li>Choosing Badge and Updating Metadata:</li> </ol> <p>After all fields are agreed upon, the reviewer selects the appropriate badge, and the metadata in the JSON file is updated accordingly.</p> <ol> <li>Exclusivity of the Process:</li> </ol> <p>If the review process has already begun, other users cannot join it until it is completed.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#new-functional-features","title":"New Functional Features","text":"<ol> <li>Badge Calculation and Visualization</li> </ol> <p>Implementation of functionality for calculating the badge by comparing the filled fields with the metadata schema. Users will be provided with a visualization of the percentage of fields that have an \"OK\" status, allowing for easier navigation through the review process.</p> <ol> <li>Review Process Optimization</li> </ol> <p>Introduction of mechanisms for optimizing the review process, including limiting the number of fields requiring human verification. This will allow focusing on the most relevant or error-prone fields, thereby enhancing the user experience and encouraging the completion of the review.</p> <ol> <li>Role of the Accompanying Person</li> </ol> <p>Addition of a new role \"accompanying person,\" endowed with extended rights of access and management of reviews. The accompanying person will have access to all reviews, be able to delete them, and will have special management tools in the user profile. The role of the accompanying person can be assigned based on the is_staff attribute.</p> <ol> <li>Displaying the Percentage</li> </ol> <p>The system will feature functionality to display the percentage of fields that are in an \"OK\" state out of the total number of fields. This feature will provide users with a quick overview of the progress made in the review process, allowing them to easily assess how many fields have been successfully validated.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#a-meta-description","title":"A Meta Description","text":""},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#what-is-the-context-what-other-parts-of-the-oep-are-connected","title":"What is the context (what other parts of the OEP are connected)?","text":"<p>This function is a part of the Open Energy Platform (OEP). It interacts with the database, loading and updating metadata, ensuring data consistency within the OEP. The function utilizes JSON and is developed using the Django framework. It also manages user access and employs specialized libraries, such as OEMETADATA_V160_SCHEMA.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#software-architecture-implementation-details","title":"Software Architecture &amp; Implementation Details","text":""},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#context","title":"Context","text":"<p>The Open Peer Review Process is designed with a modular and scalable architecture, ensuring seamless integration with existing systems and adaptability to evolving technological requirements.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#technologies","title":"Technologies","text":"<ol> <li>Python:</li> </ol> <p>The backbone of the application, Python is employed for developing core functionalities, defining data structures, and orchestrating interactions between different components.</p> <ol> <li>Django:</li> </ol> <p>This high-level Python web framework is used to encourage rapid development and clean, pragmatic design, facilitating the creation of reusable and maintainable code.</p> <ol> <li>JSON:</li> </ol> <p>JSON plays a pivotal role in structuring and handling metadata, enabling efficient data interchange between the server and client-side components.</p> <ol> <li>Jinja2:</li> </ol> <p>Leveraged for templating, Jinja2 aids in generating dynamic HTML content, thereby enhancing user interface design and user experience.</p> <ol> <li>mkdocstrings:</li> </ol> <p>This library is vital for automatically collecting Python docstrings from the source code and rendering them into the project's documentation.</p> <ol> <li>Special Libraries and Modules:</li> </ol> <p>Libraries such as OEMETADATA_V160_SCHEMA and functions like load_metadata_from_db are integrated for enhanced metadata management and interaction with the database.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#connection-to-existing-code","title":"Connection to Existing Code","text":"<p>The Open Peer Review Process system is meticulously integrated into the Open Energy Platform (OEP). It interfaces with the OEP's database to load and update metadata, ensuring data consistency across various modules. The implementation leverages Django-specific classes and methods, such as LoginRequiredMixin and View, to enforce user permissions and manage user interactions.</p> <p>Furthermore, the system utilizes existing modules and libraries, ensuring that the metadata adheres to predefined schemas and facilitating interaction with the database. The addition of new functionalities and roles, such as the \"accompanying person,\" is executed in alignment with the established codebase, ensuring that the extended rights and functionalities are seamlessly incorporated.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#conclusion","title":"Conclusion","text":"<p>By leveraging a diverse technology stack and ensuring meticulous integration with the existing codebase, the Open Peer Review Process exemplifies a robust and scalable architecture. This design philosophy not only facilitates current operations but also lays a solid foundation for future developments and enhancements.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/#changelogs","title":"Changelogs","text":"<p>Description:</p> <p>The CHANGELOG is a document that contains an organized and dated list of changes made in each version of the project. This list includes updates, bug fixes, new features, and other important notifications for users and developers.</p> <p>Purpose:</p> <p>The purpose of the CHANGELOG is to provide a clear and concise list of changes for each release, making it easier to track modifications and understand the current state of the project.</p> <p>To view a detailed list of changes for each version, follow the link to the CHANGELOGS folder.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/","title":"Technical docs","text":""},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#views","title":"Views","text":"<p>Django views.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#peerreviewview","title":"PeerReviewView","text":"<p>View for the reviewer role of the Open Peer Review process.</p> <p>               Bases: <code>LoginRequiredMixin</code>, <code>View</code></p> <p>A view handling the peer review of metadata. This view supports loading, parsing, sorting metadata, and handling GET and POST requests for peer review.</p> Source code in <code>dataedit/views.py</code> <pre><code>class PeerReviewView(LoginRequiredMixin, View):\n    \"\"\"\n    A view handling the peer review of metadata. This view supports loading,\n    parsing, sorting metadata, and handling GET and POST requests for peer review.\n    \"\"\"\n\n    def load_json(self, schema, table, review_id=None):\n        \"\"\"\n        Load JSON metadata from the database. If the review_id is available\n        then load the metadata form the peer review instance and not from the\n        table. This avoids changes to the metadata that is or was reviewed.\n\n        Args:\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n            review_id (int): Id of a peer review in the django database\n\n        Returns:\n            dict: Loaded oemetadata.\n        \"\"\"\n        metadata = {}\n        if review_id is None:\n            metadata = load_metadata_from_db(schema, table)\n        elif review_id:\n            opr = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n            metadata = opr.oemetadata\n\n        return metadata\n\n    def load_json_schema(self):\n        \"\"\"\n        Load the JSON schema used for validating metadata.\n\n        Note:\n            Update this method if a new oemetadata version is released.\n\n        Returns:\n            dict: JSON schema.\n        \"\"\"\n        json_schema = OEMETADATA_V160_SCHEMA\n        return json_schema\n\n    def parse_keys(self, val, old=\"\"):\n        \"\"\"\n        Recursively parse keys from a nested dictionary or list and return them\n        as a list of dictionaries.\n\n        Args:\n            val (dict or list): The input dictionary or list to parse.\n            old (str, optional): The prefix for nested keys. Defaults to an\n                empty string.\n\n        Returns:\n            list: A list of dictionaries, each containing 'field' and 'value'\n                keys.\n        \"\"\"\n        lines = []\n        if isinstance(val, dict):\n            for k in val.keys():\n                lines += self.parse_keys(val[k], old + \".\" + str(k))\n        elif isinstance(val, list):\n            if not val:\n                # handles empty list\n                lines += [{\"field\": old[1:], \"value\": str(val)}]\n                # pass\n            else:\n                for i, k in enumerate(val):\n                    lines += self.parse_keys(\n                        k, old + \".\" + str(i)\n                    )  # handles user value\n        else:\n            lines += [{\"field\": old[1:], \"value\": str(val)}]\n        return lines\n\n    def sort_in_category(self, schema, table, oemetadata):\n        \"\"\"\n        Sorts the metadata of a table into categories and adds the value\n        suggestion and comment that were added during the review, to facilitate\n        Further processing easier.\n\n        Note:\n            The categories spatial &amp; temporal are often combined during visualization.\n\n        Args:\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n\n        Returns:\n\n\n        Examples:\n            A return value can look like the below dictionary:\n\n            &gt;&gt;&gt;\n            {\n                \"general\": [\n                    {\n                    \"field\": \"id\",\n                    \"value\": \"http: //127.0.0.1:8000/dataedit/view/model_draft/test2\",\n                    \"newValue\": \"\",\n                    \"reviewer_suggestion\": \"\",\n                    \"suggestion_comment\": \"\"\n                    }\n                ],\n                \"spatial\": [...],\n                \"temporal\": [...],\n                \"source\": [...],\n                \"license\": [...],\n            }\n\n        \"\"\"\n\n        val = self.parse_keys(oemetadata)\n        gen_key_list = []\n        spatial_key_list = []\n        temporal_key_list = []\n        source_key_list = []\n        license_key_list = []\n\n        for i in val:\n            fieldKey = list(i.values())[0]\n            if fieldKey.split(\".\")[0] == \"spatial\":\n                spatial_key_list.append(i)\n            elif fieldKey.split(\".\")[0] == \"temporal\":\n                temporal_key_list.append(i)\n            elif fieldKey.split(\".\")[0] == \"sources\":\n                source_key_list.append(i)\n            elif fieldKey.split(\".\")[0] == \"licenses\":\n                license_key_list.append(i)\n\n            elif (\n                fieldKey.split(\".\")[0] == \"name\"\n                or fieldKey.split(\".\")[0] == \"title\"\n                or fieldKey.split(\".\")[0] == \"id\"\n                or fieldKey.split(\".\")[0] == \"description\"\n                or fieldKey.split(\".\")[0] == \"language\"\n                or fieldKey.split(\".\")[0] == \"subject\"\n                or fieldKey.split(\".\")[0] == \"keywords\"\n                or fieldKey.split(\".\")[0] == \"publicationDate\"\n                or fieldKey.split(\".\")[0] == \"context\"\n            ):\n                gen_key_list.append(i)\n\n        meta = {\n            \"general\": gen_key_list,\n            \"spatial\": spatial_key_list,\n            \"temporal\": temporal_key_list,\n            \"source\": source_key_list,\n            \"license\": license_key_list,\n        }\n\n        return meta\n\n    def get_all_field_descriptions(self, json_schema, prefix=\"\"):\n        \"\"\"\n        Collects the field title, descriptions, examples, and badge information\n        for each field of the oemetadata from the JSON schema and prepares them\n        for further processing.\n\n        Args:\n            json_schema (dict): The JSON schema to extract field descriptions\n                from.\n            prefix (str, optional): The prefix for nested keys. Defaults to an\n                empty string.\n\n        Returns:\n            dict: A dictionary containing field descriptions, examples, and\n                other information.\n        \"\"\"\n\n        field_descriptions = {}\n\n        def extract_descriptions(properties, prefix=\"\"):\n            for field, value in properties.items():\n                key = f\"{prefix}.{field}\" if prefix else field\n\n                if any(\n                    attr in value\n                    for attr in [\"description\", \"example\", \"badge\", \"title\"]\n                ):\n                    field_descriptions[key] = {}\n                    if \"description\" in value:\n                        field_descriptions[key][\"description\"] = value[\"description\"]\n                    if \"example\" in value:\n                        field_descriptions[key][\"example\"] = value[\"example\"]\n                    if \"badge\" in value:\n                        field_descriptions[key][\"badge\"] = value[\"badge\"]\n                    if \"title\" in value:\n                        field_descriptions[key][\"title\"] = value[\"title\"]\n                if \"properties\" in value:\n                    new_prefix = f\"{prefix}.{field}\" if prefix else field\n                    extract_descriptions(value[\"properties\"], new_prefix)\n                if \"items\" in value:\n                    new_prefix = f\"{prefix}.{field}\" if prefix else field\n                    if \"properties\" in value[\"items\"]:\n                        extract_descriptions(value[\"items\"][\"properties\"], new_prefix)\n\n        extract_descriptions(json_schema[\"properties\"], prefix)\n        return field_descriptions\n\n    def get(self, request, schema, table, review_id=None):\n        \"\"\"\n        Handle GET requests for peer review.\n        Loads necessary data and renders the review template.\n\n        Args:\n            request (HttpRequest): The incoming HTTP GET request.\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n            review_id (int, optional): The ID of the review. Defaults to None.\n\n        Returns:\n            HttpResponse: Rendered HTML response.\n        \"\"\"\n        # review_state = PeerReview.is_finished  # TODO: Use later\n        json_schema = self.load_json_schema()\n        can_add = False\n        table_obj = Table.load(schema, table)\n        field_descriptions = self.get_all_field_descriptions(json_schema)\n\n        # Check user permissions\n        if not request.user.is_anonymous:\n            level = request.user.get_table_permission_level(table_obj)\n            can_add = level &gt;= login_models.WRITE_PERM\n\n        oemetadata = self.load_json(schema, table, review_id)\n        metadata = self.sort_in_category(\n            schema, table, oemetadata=oemetadata\n        )  # Generate URL for peer_review_reviewer\n        if review_id is not None:\n            url_peer_review = reverse(\n                \"dataedit:peer_review_reviewer\",\n                kwargs={\"schema\": schema, \"table\": table, \"review_id\": review_id},\n            )\n            opr_review = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n            existing_review = opr_review.review.get(\"reviews\", [])\n            review_finished = opr_review.is_finished\n            categories = [\n                \"general\",\n                \"spatial\",\n                \"temporal\",\n                \"source\",\n                \"license\",\n            ]\n            state_dict = process_review_data(\n                review_data=existing_review, metadata=metadata, categories=categories\n            )\n        else:\n            url_peer_review = reverse(\n                \"dataedit:peer_review_create\", kwargs={\"schema\": schema, \"table\": table}\n            )\n            # existing_review={}\n            state_dict = None\n            review_finished = None\n\n        config_data = {\n            \"can_add\": can_add,\n            \"url_peer_review\": url_peer_review,\n            \"url_table\": reverse(\n                \"dataedit:view\", kwargs={\"schema\": schema, \"table\": table}\n            ),\n            \"topic\": schema,\n            \"table\": table,\n            \"review_finished\": review_finished,\n        }\n        context_meta = {\n            # need this here as json.dumps breaks the template syntax access\n            # like {{ config.table }} now you can use {{ table }}\n            \"table\": table,\n            \"topic\": schema,\n            \"config\": json.dumps(config_data),\n            \"meta\": metadata,\n            \"json_schema\": json_schema,\n            \"field_descriptions_json\": json.dumps(field_descriptions),\n            \"state_dict\": json.dumps(state_dict),\n        }\n        return render(request, \"dataedit/opr_review.html\", context=context_meta)\n\n    def post(self, request, schema, table, review_id=None):\n        \"\"\"\n        Handle POST requests for submitting reviews by the reviewer.\n\n        This method:\n        - Creates (or saves) reviews in the PeerReview table.\n        - Updates the review finished attribute in the dataedit.Tables table,\n            indicating that the table can be moved from the model draft topic.\n\n        Missing parts:\n        - once the opr is finished (all field reviews agreed on)\n        - merge field review results to metadata on table\n        - awarde a badge\n            - is field filled in?\n            - calculate the badge by comparing filled fields\n              and the badges form metadata schema\n\n        Args:\n            request (HttpRequest): The incoming HTTP POST request.\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n            review_id (int, optional): The ID of the review. Defaults to None.\n\n        Returns:\n            HttpResponse: Rendered HTML response for the review.\n\n        Raises:\n            JsonResponse: If any error occurs, a JsonResponse containing the\n            error message is raised.\n\n        Note:\n            - There are some missing parts in this method. Once the review process\n                is finished (all field reviews agreed on), it should merge field\n                review results to metadata on the table and award a badge based\n                on certain criteria.\n            - A notification should be sent to the user if he/she can't review tables\n            for which he/she is the table holder (TODO).\n            - After a review is finished, the table's metadata is updated, and the table\n            can be moved to a different schema or topic (TODO).\n        \"\"\"\n        context = {}\n        if request.method == \"POST\":\n            # get the review data and additional application metadata\n            # from user peer review submit/save\n            review_data = json.loads(request.body)\n            if review_id:\n                contributor_review = PeerReview.objects.filter(id=review_id).first()\n                if contributor_review:\n                    contributor_review_data = contributor_review.review.get(\n                        \"reviews\", []\n                    )\n                    review_data[\"reviewData\"][\"reviews\"].extend(contributor_review_data)\n\n            # The type can be \"save\" or \"submit\" as this triggers different behavior\n            review_post_type = review_data.get(\"reviewType\")\n            # The opr datamodel that includes the field review data and metadata\n            review_datamodel = review_data.get(\"reviewData\")\n            review_finished = review_datamodel.get(\"reviewFinished\")\n            # TODO: Send a notification to the user that he can't review tables\n            # he is the table holder.\n            contributor = PeerReviewManager.load_contributor(schema, table)\n\n            if contributor is not None:\n                # \u00dcberpr\u00fcfen, ob ein aktiver PeerReview existiert\n                active_peer_review = PeerReview.load(schema=schema, table=table)\n                if active_peer_review is None or active_peer_review.is_finished:\n                    # Kein aktiver PeerReview vorhanden\n                    # oder der aktive PeerReview ist abgeschlossen\n                    table_review = PeerReview(\n                        schema=schema,\n                        table=table,\n                        is_finished=review_finished,\n                        review=review_datamodel,\n                        reviewer=request.user,\n                        contributor=contributor,\n                        oemetadata=load_metadata_from_db(schema=schema, table=table),\n                    )\n                    table_review.save(review_type=review_post_type)\n                else:\n                    # Aktiver PeerReview ist vorhanden ... aktualisieren\n                    current_review_data = active_peer_review.review\n                    merged_review_data = merge_field_reviews(\n                        current_json=current_review_data, new_json=review_datamodel\n                    )\n\n                    # Set new review values and update existing review\n                    active_peer_review.review = merged_review_data\n                    active_peer_review.reviewer = request.user\n                    active_peer_review.contributor = contributor\n                    active_peer_review.update(review_type=review_post_type)\n            else:\n                error_msg = (\n                    \"Failed to retrieve any user that identifies \"\n                    f\"as table holder for the current table: {table}!\"\n                )\n                return JsonResponse({\"error\": error_msg}, status=400)\n\n            # TODO: Check for schema/topic as reviewed finished also indicates the table\n            # needs to be or has to be moved.\n            if review_finished is True:\n                review_table = Table.load(schema=schema, table=table)\n                review_table.set_is_reviewed()\n                metadata = self.load_json(schema, table, review_id=review_id)\n\n                recursive_update(metadata, review_data)\n\n                save_metadata_to_db(schema, table, metadata)\n\n                if active_peer_review:\n                    # Update the oemetadata in the active PeerReview\n                    active_peer_review.oemetadata = metadata\n                    active_peer_review.save()\n\n                # TODO: also update reviewFinished in review datamodel json\n                # logging.INFO(f\"Table {table.name} is now reviewed and can be moved\n                # to the destination schema.\")\n\n        return render(request, \"dataedit/opr_review.html\", context=context)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.get","title":"<code>get(request, schema, table, review_id=None)</code>","text":"<p>Handle GET requests for peer review. Loads necessary data and renders the review template.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <code>review_id</code> <code>int</code> <p>The ID of the review. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>HttpResponse</code> <p>Rendered HTML response.</p> Source code in <code>dataedit/views.py</code> <pre><code>def get(self, request, schema, table, review_id=None):\n    \"\"\"\n    Handle GET requests for peer review.\n    Loads necessary data and renders the review template.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n        review_id (int, optional): The ID of the review. Defaults to None.\n\n    Returns:\n        HttpResponse: Rendered HTML response.\n    \"\"\"\n    # review_state = PeerReview.is_finished  # TODO: Use later\n    json_schema = self.load_json_schema()\n    can_add = False\n    table_obj = Table.load(schema, table)\n    field_descriptions = self.get_all_field_descriptions(json_schema)\n\n    # Check user permissions\n    if not request.user.is_anonymous:\n        level = request.user.get_table_permission_level(table_obj)\n        can_add = level &gt;= login_models.WRITE_PERM\n\n    oemetadata = self.load_json(schema, table, review_id)\n    metadata = self.sort_in_category(\n        schema, table, oemetadata=oemetadata\n    )  # Generate URL for peer_review_reviewer\n    if review_id is not None:\n        url_peer_review = reverse(\n            \"dataedit:peer_review_reviewer\",\n            kwargs={\"schema\": schema, \"table\": table, \"review_id\": review_id},\n        )\n        opr_review = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n        existing_review = opr_review.review.get(\"reviews\", [])\n        review_finished = opr_review.is_finished\n        categories = [\n            \"general\",\n            \"spatial\",\n            \"temporal\",\n            \"source\",\n            \"license\",\n        ]\n        state_dict = process_review_data(\n            review_data=existing_review, metadata=metadata, categories=categories\n        )\n    else:\n        url_peer_review = reverse(\n            \"dataedit:peer_review_create\", kwargs={\"schema\": schema, \"table\": table}\n        )\n        # existing_review={}\n        state_dict = None\n        review_finished = None\n\n    config_data = {\n        \"can_add\": can_add,\n        \"url_peer_review\": url_peer_review,\n        \"url_table\": reverse(\n            \"dataedit:view\", kwargs={\"schema\": schema, \"table\": table}\n        ),\n        \"topic\": schema,\n        \"table\": table,\n        \"review_finished\": review_finished,\n    }\n    context_meta = {\n        # need this here as json.dumps breaks the template syntax access\n        # like {{ config.table }} now you can use {{ table }}\n        \"table\": table,\n        \"topic\": schema,\n        \"config\": json.dumps(config_data),\n        \"meta\": metadata,\n        \"json_schema\": json_schema,\n        \"field_descriptions_json\": json.dumps(field_descriptions),\n        \"state_dict\": json.dumps(state_dict),\n    }\n    return render(request, \"dataedit/opr_review.html\", context=context_meta)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.get_all_field_descriptions","title":"<code>get_all_field_descriptions(json_schema, prefix='')</code>","text":"<p>Collects the field title, descriptions, examples, and badge information for each field of the oemetadata from the JSON schema and prepares them for further processing.</p> <p>Parameters:</p> Name Type Description Default <code>json_schema</code> <code>dict</code> <p>The JSON schema to extract field descriptions from.</p> required <code>prefix</code> <code>str</code> <p>The prefix for nested keys. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing field descriptions, examples, and other information.</p> Source code in <code>dataedit/views.py</code> <pre><code>def get_all_field_descriptions(self, json_schema, prefix=\"\"):\n    \"\"\"\n    Collects the field title, descriptions, examples, and badge information\n    for each field of the oemetadata from the JSON schema and prepares them\n    for further processing.\n\n    Args:\n        json_schema (dict): The JSON schema to extract field descriptions\n            from.\n        prefix (str, optional): The prefix for nested keys. Defaults to an\n            empty string.\n\n    Returns:\n        dict: A dictionary containing field descriptions, examples, and\n            other information.\n    \"\"\"\n\n    field_descriptions = {}\n\n    def extract_descriptions(properties, prefix=\"\"):\n        for field, value in properties.items():\n            key = f\"{prefix}.{field}\" if prefix else field\n\n            if any(\n                attr in value\n                for attr in [\"description\", \"example\", \"badge\", \"title\"]\n            ):\n                field_descriptions[key] = {}\n                if \"description\" in value:\n                    field_descriptions[key][\"description\"] = value[\"description\"]\n                if \"example\" in value:\n                    field_descriptions[key][\"example\"] = value[\"example\"]\n                if \"badge\" in value:\n                    field_descriptions[key][\"badge\"] = value[\"badge\"]\n                if \"title\" in value:\n                    field_descriptions[key][\"title\"] = value[\"title\"]\n            if \"properties\" in value:\n                new_prefix = f\"{prefix}.{field}\" if prefix else field\n                extract_descriptions(value[\"properties\"], new_prefix)\n            if \"items\" in value:\n                new_prefix = f\"{prefix}.{field}\" if prefix else field\n                if \"properties\" in value[\"items\"]:\n                    extract_descriptions(value[\"items\"][\"properties\"], new_prefix)\n\n    extract_descriptions(json_schema[\"properties\"], prefix)\n    return field_descriptions\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.load_json","title":"<code>load_json(schema, table, review_id=None)</code>","text":"<p>Load JSON metadata from the database. If the review_id is available then load the metadata form the peer review instance and not from the table. This avoids changes to the metadata that is or was reviewed.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <code>review_id</code> <code>int</code> <p>Id of a peer review in the django database</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Loaded oemetadata.</p> Source code in <code>dataedit/views.py</code> <pre><code>def load_json(self, schema, table, review_id=None):\n    \"\"\"\n    Load JSON metadata from the database. If the review_id is available\n    then load the metadata form the peer review instance and not from the\n    table. This avoids changes to the metadata that is or was reviewed.\n\n    Args:\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n        review_id (int): Id of a peer review in the django database\n\n    Returns:\n        dict: Loaded oemetadata.\n    \"\"\"\n    metadata = {}\n    if review_id is None:\n        metadata = load_metadata_from_db(schema, table)\n    elif review_id:\n        opr = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n        metadata = opr.oemetadata\n\n    return metadata\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.load_json_schema","title":"<code>load_json_schema()</code>","text":"<p>Load the JSON schema used for validating metadata.</p> Note <p>Update this method if a new oemetadata version is released.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>JSON schema.</p> Source code in <code>dataedit/views.py</code> <pre><code>def load_json_schema(self):\n    \"\"\"\n    Load the JSON schema used for validating metadata.\n\n    Note:\n        Update this method if a new oemetadata version is released.\n\n    Returns:\n        dict: JSON schema.\n    \"\"\"\n    json_schema = OEMETADATA_V160_SCHEMA\n    return json_schema\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.parse_keys","title":"<code>parse_keys(val, old='')</code>","text":"<p>Recursively parse keys from a nested dictionary or list and return them as a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>dict or list</code> <p>The input dictionary or list to parse.</p> required <code>old</code> <code>str</code> <p>The prefix for nested keys. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries, each containing 'field' and 'value' keys.</p> Source code in <code>dataedit/views.py</code> <pre><code>def parse_keys(self, val, old=\"\"):\n    \"\"\"\n    Recursively parse keys from a nested dictionary or list and return them\n    as a list of dictionaries.\n\n    Args:\n        val (dict or list): The input dictionary or list to parse.\n        old (str, optional): The prefix for nested keys. Defaults to an\n            empty string.\n\n    Returns:\n        list: A list of dictionaries, each containing 'field' and 'value'\n            keys.\n    \"\"\"\n    lines = []\n    if isinstance(val, dict):\n        for k in val.keys():\n            lines += self.parse_keys(val[k], old + \".\" + str(k))\n    elif isinstance(val, list):\n        if not val:\n            # handles empty list\n            lines += [{\"field\": old[1:], \"value\": str(val)}]\n            # pass\n        else:\n            for i, k in enumerate(val):\n                lines += self.parse_keys(\n                    k, old + \".\" + str(i)\n                )  # handles user value\n    else:\n        lines += [{\"field\": old[1:], \"value\": str(val)}]\n    return lines\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.post","title":"<code>post(request, schema, table, review_id=None)</code>","text":"<p>Handle POST requests for submitting reviews by the reviewer.</p> <p>This method: - Creates (or saves) reviews in the PeerReview table. - Updates the review finished attribute in the dataedit.Tables table,     indicating that the table can be moved from the model draft topic.</p> <p>Missing parts: - once the opr is finished (all field reviews agreed on) - merge field review results to metadata on table - awarde a badge     - is field filled in?     - calculate the badge by comparing filled fields       and the badges form metadata schema</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP POST request.</p> required <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <code>review_id</code> <code>int</code> <p>The ID of the review. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>HttpResponse</code> <p>Rendered HTML response for the review.</p> <p>Raises:</p> Type Description <code>JsonResponse</code> <p>If any error occurs, a JsonResponse containing the</p> Note <ul> <li>There are some missing parts in this method. Once the review process     is finished (all field reviews agreed on), it should merge field     review results to metadata on the table and award a badge based     on certain criteria.</li> <li>A notification should be sent to the user if he/she can't review tables for which he/she is the table holder (TODO).</li> <li>After a review is finished, the table's metadata is updated, and the table can be moved to a different schema or topic (TODO).</li> </ul> Source code in <code>dataedit/views.py</code> <pre><code>def post(self, request, schema, table, review_id=None):\n    \"\"\"\n    Handle POST requests for submitting reviews by the reviewer.\n\n    This method:\n    - Creates (or saves) reviews in the PeerReview table.\n    - Updates the review finished attribute in the dataedit.Tables table,\n        indicating that the table can be moved from the model draft topic.\n\n    Missing parts:\n    - once the opr is finished (all field reviews agreed on)\n    - merge field review results to metadata on table\n    - awarde a badge\n        - is field filled in?\n        - calculate the badge by comparing filled fields\n          and the badges form metadata schema\n\n    Args:\n        request (HttpRequest): The incoming HTTP POST request.\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n        review_id (int, optional): The ID of the review. Defaults to None.\n\n    Returns:\n        HttpResponse: Rendered HTML response for the review.\n\n    Raises:\n        JsonResponse: If any error occurs, a JsonResponse containing the\n        error message is raised.\n\n    Note:\n        - There are some missing parts in this method. Once the review process\n            is finished (all field reviews agreed on), it should merge field\n            review results to metadata on the table and award a badge based\n            on certain criteria.\n        - A notification should be sent to the user if he/she can't review tables\n        for which he/she is the table holder (TODO).\n        - After a review is finished, the table's metadata is updated, and the table\n        can be moved to a different schema or topic (TODO).\n    \"\"\"\n    context = {}\n    if request.method == \"POST\":\n        # get the review data and additional application metadata\n        # from user peer review submit/save\n        review_data = json.loads(request.body)\n        if review_id:\n            contributor_review = PeerReview.objects.filter(id=review_id).first()\n            if contributor_review:\n                contributor_review_data = contributor_review.review.get(\n                    \"reviews\", []\n                )\n                review_data[\"reviewData\"][\"reviews\"].extend(contributor_review_data)\n\n        # The type can be \"save\" or \"submit\" as this triggers different behavior\n        review_post_type = review_data.get(\"reviewType\")\n        # The opr datamodel that includes the field review data and metadata\n        review_datamodel = review_data.get(\"reviewData\")\n        review_finished = review_datamodel.get(\"reviewFinished\")\n        # TODO: Send a notification to the user that he can't review tables\n        # he is the table holder.\n        contributor = PeerReviewManager.load_contributor(schema, table)\n\n        if contributor is not None:\n            # \u00dcberpr\u00fcfen, ob ein aktiver PeerReview existiert\n            active_peer_review = PeerReview.load(schema=schema, table=table)\n            if active_peer_review is None or active_peer_review.is_finished:\n                # Kein aktiver PeerReview vorhanden\n                # oder der aktive PeerReview ist abgeschlossen\n                table_review = PeerReview(\n                    schema=schema,\n                    table=table,\n                    is_finished=review_finished,\n                    review=review_datamodel,\n                    reviewer=request.user,\n                    contributor=contributor,\n                    oemetadata=load_metadata_from_db(schema=schema, table=table),\n                )\n                table_review.save(review_type=review_post_type)\n            else:\n                # Aktiver PeerReview ist vorhanden ... aktualisieren\n                current_review_data = active_peer_review.review\n                merged_review_data = merge_field_reviews(\n                    current_json=current_review_data, new_json=review_datamodel\n                )\n\n                # Set new review values and update existing review\n                active_peer_review.review = merged_review_data\n                active_peer_review.reviewer = request.user\n                active_peer_review.contributor = contributor\n                active_peer_review.update(review_type=review_post_type)\n        else:\n            error_msg = (\n                \"Failed to retrieve any user that identifies \"\n                f\"as table holder for the current table: {table}!\"\n            )\n            return JsonResponse({\"error\": error_msg}, status=400)\n\n        # TODO: Check for schema/topic as reviewed finished also indicates the table\n        # needs to be or has to be moved.\n        if review_finished is True:\n            review_table = Table.load(schema=schema, table=table)\n            review_table.set_is_reviewed()\n            metadata = self.load_json(schema, table, review_id=review_id)\n\n            recursive_update(metadata, review_data)\n\n            save_metadata_to_db(schema, table, metadata)\n\n            if active_peer_review:\n                # Update the oemetadata in the active PeerReview\n                active_peer_review.oemetadata = metadata\n                active_peer_review.save()\n\n            # TODO: also update reviewFinished in review datamodel json\n            # logging.INFO(f\"Table {table.name} is now reviewed and can be moved\n            # to the destination schema.\")\n\n    return render(request, \"dataedit/opr_review.html\", context=context)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerReviewView.sort_in_category","title":"<code>sort_in_category(schema, table, oemetadata)</code>","text":"<p>Sorts the metadata of a table into categories and adds the value suggestion and comment that were added during the review, to facilitate Further processing easier.</p> Note <p>The categories spatial &amp; temporal are often combined during visualization.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <p>Returns:</p> <p>Examples:</p> <p>A return value can look like the below dictionary:</p> <pre><code>&gt;&gt;&gt;\n{\n    \"general\": [\n        {\n        \"field\": \"id\",\n        \"value\": \"http: //127.0.0.1:8000/dataedit/view/model_draft/test2\",\n        \"newValue\": \"\",\n        \"reviewer_suggestion\": \"\",\n        \"suggestion_comment\": \"\"\n        }\n    ],\n    \"spatial\": [...],\n    \"temporal\": [...],\n    \"source\": [...],\n    \"license\": [...],\n}\n</code></pre> Source code in <code>dataedit/views.py</code> <pre><code>def sort_in_category(self, schema, table, oemetadata):\n    \"\"\"\n    Sorts the metadata of a table into categories and adds the value\n    suggestion and comment that were added during the review, to facilitate\n    Further processing easier.\n\n    Note:\n        The categories spatial &amp; temporal are often combined during visualization.\n\n    Args:\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n\n    Returns:\n\n\n    Examples:\n        A return value can look like the below dictionary:\n\n        &gt;&gt;&gt;\n        {\n            \"general\": [\n                {\n                \"field\": \"id\",\n                \"value\": \"http: //127.0.0.1:8000/dataedit/view/model_draft/test2\",\n                \"newValue\": \"\",\n                \"reviewer_suggestion\": \"\",\n                \"suggestion_comment\": \"\"\n                }\n            ],\n            \"spatial\": [...],\n            \"temporal\": [...],\n            \"source\": [...],\n            \"license\": [...],\n        }\n\n    \"\"\"\n\n    val = self.parse_keys(oemetadata)\n    gen_key_list = []\n    spatial_key_list = []\n    temporal_key_list = []\n    source_key_list = []\n    license_key_list = []\n\n    for i in val:\n        fieldKey = list(i.values())[0]\n        if fieldKey.split(\".\")[0] == \"spatial\":\n            spatial_key_list.append(i)\n        elif fieldKey.split(\".\")[0] == \"temporal\":\n            temporal_key_list.append(i)\n        elif fieldKey.split(\".\")[0] == \"sources\":\n            source_key_list.append(i)\n        elif fieldKey.split(\".\")[0] == \"licenses\":\n            license_key_list.append(i)\n\n        elif (\n            fieldKey.split(\".\")[0] == \"name\"\n            or fieldKey.split(\".\")[0] == \"title\"\n            or fieldKey.split(\".\")[0] == \"id\"\n            or fieldKey.split(\".\")[0] == \"description\"\n            or fieldKey.split(\".\")[0] == \"language\"\n            or fieldKey.split(\".\")[0] == \"subject\"\n            or fieldKey.split(\".\")[0] == \"keywords\"\n            or fieldKey.split(\".\")[0] == \"publicationDate\"\n            or fieldKey.split(\".\")[0] == \"context\"\n        ):\n            gen_key_list.append(i)\n\n    meta = {\n        \"general\": gen_key_list,\n        \"spatial\": spatial_key_list,\n        \"temporal\": temporal_key_list,\n        \"source\": source_key_list,\n        \"license\": license_key_list,\n    }\n\n    return meta\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#peerrreviewcontributorview","title":"PeerRreviewContributorView","text":"<p>View for the contributor role of the Open Peer Review process.</p> <p>               Bases: <code>PeerReviewView</code></p> <p>A view handling the contributor's side of the peer review process. This view supports rendering the review template and handling GET and POST requests for contributor's review.</p> Source code in <code>dataedit/views.py</code> <pre><code>class PeerRreviewContributorView(PeerReviewView):\n    \"\"\"\n    A view handling the contributor's side of the peer review process.\n    This view supports rendering the review template and handling GET and\n    POST requests for contributor's review.\n    \"\"\"\n\n    def get(self, request, schema, table, review_id):\n        \"\"\"\n        Handle GET requests for contributor's review. Loads necessary data and\n        renders the contributor review template.\n\n        Args:\n            request (HttpRequest): The incoming HTTP GET request.\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n            review_id (int): The ID of the review.\n\n        Returns:\n            HttpResponse: Rendered HTML response for contributor review.\n        \"\"\"\n        can_add = False\n        peer_review = PeerReview.objects.get(id=review_id)\n        table_obj = Table.load(peer_review.schema, peer_review.table)\n        if not request.user.is_anonymous:\n            level = request.user.get_table_permission_level(table_obj)\n            can_add = level &gt;= login_models.WRITE_PERM\n        oemetadata = self.load_json(schema, table, review_id)\n        metadata = self.sort_in_category(schema, table, oemetadata=oemetadata)\n        json_schema = self.load_json_schema()\n        field_descriptions = self.get_all_field_descriptions(json_schema)\n        review_data = peer_review.review.get(\"reviews\", [])\n\n        categories = [\n            \"general\",\n            \"spatial\",\n            \"temporal\",\n            \"source\",\n            \"license\",\n        ]\n        state_dict = process_review_data(\n            review_data=review_data, metadata=metadata, categories=categories\n        )\n        context_meta = {\n            \"config\": json.dumps(\n                {\n                    \"can_add\": can_add,\n                    \"url_peer_review\": reverse(\n                        \"dataedit:peer_review_contributor\",\n                        kwargs={\n                            \"schema\": schema,\n                            \"table\": table,\n                            \"review_id\": review_id,\n                        },\n                    ),\n                    \"url_table\": reverse(\n                        \"dataedit:view\", kwargs={\"schema\": schema, \"table\": table}\n                    ),\n                    \"topic\": schema,\n                    \"table\": table,\n                }\n            ),\n            \"table\": table,\n            \"topic\": schema,\n            \"meta\": metadata,\n            \"json_schema\": json_schema,\n            \"field_descriptions_json\": json.dumps(field_descriptions),\n            \"state_dict\": json.dumps(state_dict),\n        }\n        return render(request, \"dataedit/opr_contributor.html\", context=context_meta)\n\n    def post(self, request, schema, table, review_id):\n        \"\"\"\n        Handle POST requests for contributor's review. Merges and updates\n        the review data in the PeerReview table.\n\n        Missing parts:\n            - merge contributor field review and reviewer field review\n\n        Args:\n            request (HttpRequest): The incoming HTTP POST request.\n            schema (str): The schema of the table.\n            table (str): The name of the table.\n            review_id (int): The ID of the review.\n\n        Returns:\n            HttpResponse: Rendered HTML response for contributor review.\n\n        Note:\n            This method has some missing parts regarding the merging of contributor\n            and reviewer field review.\n        \"\"\"\n\n        context = {}\n        if request.method == \"POST\":\n            review_data = json.loads(request.body)\n            review_post_type = review_data.get(\"reviewType\")\n            review_datamodel = review_data.get(\"reviewData\")\n            # unused\n            # review_state = review_data.get(\"reviewFinished\")\n            current_opr = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n            existing_reviews = current_opr.review\n            merged_review = merge_field_reviews(\n                current_json=existing_reviews, new_json=review_datamodel\n            )\n\n            current_opr.review = merged_review\n            current_opr.update(review_type=review_post_type)\n\n        return render(request, \"dataedit/opr_contributor.html\", context=context)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerRreviewContributorView.get","title":"<code>get(request, schema, table, review_id)</code>","text":"<p>Handle GET requests for contributor's review. Loads necessary data and renders the contributor review template.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <code>review_id</code> <code>int</code> <p>The ID of the review.</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <p>Rendered HTML response for contributor review.</p> Source code in <code>dataedit/views.py</code> <pre><code>def get(self, request, schema, table, review_id):\n    \"\"\"\n    Handle GET requests for contributor's review. Loads necessary data and\n    renders the contributor review template.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n        review_id (int): The ID of the review.\n\n    Returns:\n        HttpResponse: Rendered HTML response for contributor review.\n    \"\"\"\n    can_add = False\n    peer_review = PeerReview.objects.get(id=review_id)\n    table_obj = Table.load(peer_review.schema, peer_review.table)\n    if not request.user.is_anonymous:\n        level = request.user.get_table_permission_level(table_obj)\n        can_add = level &gt;= login_models.WRITE_PERM\n    oemetadata = self.load_json(schema, table, review_id)\n    metadata = self.sort_in_category(schema, table, oemetadata=oemetadata)\n    json_schema = self.load_json_schema()\n    field_descriptions = self.get_all_field_descriptions(json_schema)\n    review_data = peer_review.review.get(\"reviews\", [])\n\n    categories = [\n        \"general\",\n        \"spatial\",\n        \"temporal\",\n        \"source\",\n        \"license\",\n    ]\n    state_dict = process_review_data(\n        review_data=review_data, metadata=metadata, categories=categories\n    )\n    context_meta = {\n        \"config\": json.dumps(\n            {\n                \"can_add\": can_add,\n                \"url_peer_review\": reverse(\n                    \"dataedit:peer_review_contributor\",\n                    kwargs={\n                        \"schema\": schema,\n                        \"table\": table,\n                        \"review_id\": review_id,\n                    },\n                ),\n                \"url_table\": reverse(\n                    \"dataedit:view\", kwargs={\"schema\": schema, \"table\": table}\n                ),\n                \"topic\": schema,\n                \"table\": table,\n            }\n        ),\n        \"table\": table,\n        \"topic\": schema,\n        \"meta\": metadata,\n        \"json_schema\": json_schema,\n        \"field_descriptions_json\": json.dumps(field_descriptions),\n        \"state_dict\": json.dumps(state_dict),\n    }\n    return render(request, \"dataedit/opr_contributor.html\", context=context_meta)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.views.PeerRreviewContributorView.post","title":"<code>post(request, schema, table, review_id)</code>","text":"<p>Handle POST requests for contributor's review. Merges and updates the review data in the PeerReview table.</p> Missing parts <ul> <li>merge contributor field review and reviewer field review</li> </ul> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP POST request.</p> required <code>schema</code> <code>str</code> <p>The schema of the table.</p> required <code>table</code> <code>str</code> <p>The name of the table.</p> required <code>review_id</code> <code>int</code> <p>The ID of the review.</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <p>Rendered HTML response for contributor review.</p> Note <p>This method has some missing parts regarding the merging of contributor and reviewer field review.</p> Source code in <code>dataedit/views.py</code> <pre><code>def post(self, request, schema, table, review_id):\n    \"\"\"\n    Handle POST requests for contributor's review. Merges and updates\n    the review data in the PeerReview table.\n\n    Missing parts:\n        - merge contributor field review and reviewer field review\n\n    Args:\n        request (HttpRequest): The incoming HTTP POST request.\n        schema (str): The schema of the table.\n        table (str): The name of the table.\n        review_id (int): The ID of the review.\n\n    Returns:\n        HttpResponse: Rendered HTML response for contributor review.\n\n    Note:\n        This method has some missing parts regarding the merging of contributor\n        and reviewer field review.\n    \"\"\"\n\n    context = {}\n    if request.method == \"POST\":\n        review_data = json.loads(request.body)\n        review_post_type = review_data.get(\"reviewType\")\n        review_datamodel = review_data.get(\"reviewData\")\n        # unused\n        # review_state = review_data.get(\"reviewFinished\")\n        current_opr = PeerReviewManager.filter_opr_by_id(opr_id=review_id)\n        existing_reviews = current_opr.review\n        merged_review = merge_field_reviews(\n            current_json=existing_reviews, new_json=review_datamodel\n        )\n\n        current_opr.review = merged_review\n        current_opr.update(review_type=review_post_type)\n\n    return render(request, \"dataedit/opr_contributor.html\", context=context)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#helper-functions","title":"Helper Functions","text":"<p>Separated functionality that can be imported in other modules. It contains several functions that help with recurring tasks in the peer review system.</p> <p>Provide helper functionality for views to reduce code lines in views.py make the codebase more modular.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.get_readable_table_name","title":"<code>get_readable_table_name(table_obj)</code>","text":"<p>get readable table name from metadata</p> <p>Parameters:</p> Name Type Description Default <code>table_obj</code> <code>object</code> <p>django orm</p> required <p>Returns:</p> Type Description <code>str</code> <p>str</p> Source code in <code>dataedit/helper.py</code> <pre><code>def get_readable_table_name(table_obj: Table) -&gt; str:\n    \"\"\"get readable table name from metadata\n\n    Args:\n        table_obj (object): django orm\n\n    Returns:\n        str\n    \"\"\"\n\n    try:\n        label = read_label(table_obj.name, table_obj.oemetadata)\n    except Exception as e:\n        raise e\n    return label\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.get_review_for_key","title":"<code>get_review_for_key(key, review_data)</code>","text":"<p>Retrieve the review for a specific key from the review data.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for which to retrieve the review. review_data (dict): The review data containing reviews for various keys.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The new value associated with the specified key in the review data, or None if the key is not found.</p> Source code in <code>dataedit/helper.py</code> <pre><code>def get_review_for_key(key, review_data):\n    \"\"\"\n    Retrieve the review for a specific key from the review data.\n\n    Args:\n        key (str): The key for which to retrieve the review.\n            review_data (dict): The review data containing\n            reviews for various keys.\n\n    Returns:\n        Any: The new value associated with the specified key\n            in the review data, or None if the key is not found.\n    \"\"\"\n\n    for review in review_data[\"reviewData\"][\"reviews\"]:\n        if review[\"key\"] == key:\n            return review[\"fieldReview\"].get(\"newValue\", None)\n    return None\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.merge_field_reviews","title":"<code>merge_field_reviews(current_json, new_json)</code>","text":"<p>Merge reviews from contributors and reviewers into a single JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>current_json</code> <code>dict</code> <p>The current JSON object containing reviewer's reviews.</p> required <code>new_json</code> <code>dict</code> <p>The new JSON object containing contributor's reviews.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The merged JSON object containing both contributor's and reviewer's reviews.</p> Note <p>If the same key is present in both the contributor's and     reviewer's reviews, the function will merge the field     evaluations. Otherwise, it will create a new entry in     the Review-Dict.</p> Source code in <code>dataedit/helper.py</code> <pre><code>def merge_field_reviews(current_json, new_json):\n    \"\"\"\n    Merge reviews from contributors and reviewers into a single JSON object.\n\n    Args:\n        current_json (dict): The current JSON object containing\n            reviewer's reviews.\n        new_json (dict): The new JSON object containing contributor's reviews.\n\n    Returns:\n        dict: The merged JSON object containing both contributor's and\n            reviewer's reviews.\n\n    Note:\n        If the same key is present in both the contributor's and\n            reviewer's reviews, the function will merge the field\n            evaluations. Otherwise, it will create a new entry in\n            the Review-Dict.\n    \"\"\"\n    merged_json = new_json.copy()\n    review_dict = {}\n\n    for contrib_review in merged_json[\"reviews\"]:\n        category = contrib_review[\"category\"]\n        key = contrib_review[\"key\"]\n        review_dict[(category, key)] = contrib_review[\"fieldReview\"]\n\n    for reviewer_review in current_json[\"reviews\"]:\n        category = reviewer_review[\"category\"]\n        key = reviewer_review[\"key\"]\n\n        if (category, key) in review_dict:\n            # Add field evaluations to the existing entry\n            existing_field_review = review_dict[(category, key)]\n            if isinstance(existing_field_review, dict):\n                existing_field_review = [existing_field_review]\n            if isinstance(reviewer_review[\"fieldReview\"], dict):\n                reviewer_review[\"fieldReview\"] = [reviewer_review[\"fieldReview\"]]\n            merged_field_review = existing_field_review + reviewer_review[\"fieldReview\"]\n            review_dict[(category, key)] = merged_field_review\n        else:\n            # Create new entry in Review-Dict\n            review_dict[(category, key)] = reviewer_review[\"fieldReview\"]\n\n    # Insert updated field scores back into the JSON\n    merged_json[\"reviews\"] = [\n        {\"category\": category, \"key\": key, \"fieldReview\": review_dict[(category, key)]}\n        for category, key in review_dict\n    ]\n\n    return merged_json\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.process_review_data","title":"<code>process_review_data(review_data, metadata, categories)</code>","text":"<p>Process the review data and update the metadata with the latest reviews and suggestions.</p> <p>Parameters:</p> Name Type Description Default <code>review_data</code> <code>list</code> <p>A list of dictionaries containing review data for                 each field.</p> required <code>metadata</code> <code>dict</code> <p>The original metadata object that needs to be updated.</p> required <code>categories</code> <code>list</code> <p>A list of categories in the metadata.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A state dictionary containing the state of each field after processing the review data.</p> Note <p>The function sorts the fieldReview entries by timestamp (newest first) and updates the metadata with the latest reviewer suggestions, comments, and new values. The resulting state dictionary indicates the state of each field after processing.</p> Source code in <code>dataedit/helper.py</code> <pre><code>def process_review_data(review_data, metadata, categories):\n    \"\"\"\n    Process the review data and update the metadata with the latest reviews\n    and suggestions.\n\n    Args:\n        review_data (list): A list of dictionaries containing review data for\n                            each field.\n        metadata (dict): The original metadata object that needs to be updated.\n        categories (list): A list of categories in the metadata.\n\n    Returns:\n        dict: A state dictionary containing the state of each field\n            after processing the review data.\n\n    Note:\n        The function sorts the fieldReview entries by timestamp (newest first)\n        and updates the metadata with the latest reviewer suggestions,\n        comments, and new values. The resulting state dictionary indicates\n        the state of each field after processing.\n    \"\"\"\n    state_dict = {}\n\n    for review in review_data:\n        field_key = review.get(\"key\")\n        field_review = review.get(\"fieldReview\")\n\n        if isinstance(field_review, list):\n            # Sortiere die fieldReview-Eintr\u00e4ge nach dem timestamp (neueste zuerst)\n            sorted_field_review = sorted(\n                field_review, key=lambda x: x.get(\"timestamp\"), reverse=True\n            )\n            latest_field_review = (\n                sorted_field_review[0] if sorted_field_review else None\n            )\n\n            if latest_field_review:\n                state = latest_field_review.get(\"state\")\n                reviewer_suggestion = latest_field_review.get(\"reviewerSuggestion\")\n                reviewer_suggestion_comment = latest_field_review.get(\"comment\")\n                newValue = latest_field_review.get(\"newValue\")\n            else:\n                state = None\n                reviewer_suggestion = None\n                reviewer_suggestion_comment = None\n                newValue = None\n        else:\n            state = field_review.get(\"state\")\n            reviewer_suggestion = field_review.get(\"reviewerSuggestion\")\n            reviewer_suggestion_comment = field_review.get(\"comment\")\n            newValue = field_review.get(\"newValue\")\n\n        if reviewer_suggestion is not None and reviewer_suggestion_comment is not None:\n            for category in categories:\n                for item in metadata[category]:\n                    if item[\"field\"] == field_key:\n                        item[\"reviewer_suggestion\"] = reviewer_suggestion\n                        item[\"suggestion_comment\"] = reviewer_suggestion_comment\n                        break\n\n        if newValue is not None:\n            for category in categories:\n                for item in metadata[category]:\n                    if item[\"field\"] == field_key:\n                        item[\"newValue\"] = newValue\n                        break\n\n        state_dict[field_key] = state\n\n    return state_dict\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.read_label","title":"<code>read_label(table, oemetadata)</code>","text":"<p>Extracts the readable name from @comment and appends the real name in parens. If comment is not a JSON-dictionary or does not contain a field 'Name' None is returned.</p> <p>:param table: Name to append</p> <p>:param comment: String containing a JSON-dictionary according to @Metadata</p> <p>:return: Readable name appended by the true table name as string or None</p> Source code in <code>dataedit/helper.py</code> <pre><code>def read_label(table, oemetadata) -&gt; str:\n    \"\"\"\n    Extracts the readable name from @comment and appends the real name in parens.\n    If comment is not a JSON-dictionary or does not contain a field 'Name' None\n    is returned.\n\n    :param table: Name to append\n\n    :param comment: String containing a JSON-dictionary according to @Metadata\n\n    :return: Readable name appended by the true table name as string or None\n    \"\"\"\n    try:\n        if oemetadata.get(\"title\"):\n            return oemetadata[\"title\"].strip() + \" (\" + table + \")\"\n        elif oemetadata.get(\"Title\"):\n            return oemetadata[\"Title\"].strip() + \" (\" + table + \")\"\n\n        else:\n            return None\n\n    except Exception:\n        return None\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.recursive_update","title":"<code>recursive_update(metadata, review_data)</code>","text":"<p>Recursively update the metadata with new values from the review data.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The original metadata dictionary to be updated.</p> required <code>review_data</code> <code>dict</code> <p>The review data containing new values for various keys.</p> required Note <p>The function traverses the review data, and for each key, it updates the corresponding value in the metadata if a new value is present and is not an empty string.</p> Source code in <code>dataedit/helper.py</code> <pre><code>def recursive_update(metadata, review_data):\n    \"\"\"\n    Recursively update the metadata with new values from the review data.\n\n    Args:\n        metadata (dict): The original metadata dictionary to be updated.\n        review_data (dict): The review data containing new values for various keys.\n\n    Note:\n        The function traverses the review data, and for each key, it updates the\n        corresponding value in the metadata if a new value is present and is not\n        an empty string.\n    \"\"\"\n\n    for review_key in review_data[\"reviewData\"][\"reviews\"]:\n        keys = review_key[\"key\"].split(\".\")\n\n        if isinstance(review_key[\"fieldReview\"], list):\n            for field_review in review_key[\"fieldReview\"]:\n                new_value = field_review.get(\"newValue\", None)\n                if new_value is not None and new_value != \"\":\n                    set_nested_value(metadata, keys, new_value)\n        else:\n            new_value = review_key[\"fieldReview\"].get(\"newValue\", None)\n            if new_value is not None and new_value != \"\":\n                set_nested_value(metadata, keys, new_value)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.helper.set_nested_value","title":"<code>set_nested_value(metadata, keys, value)</code>","text":"<p>Set a nested value in a dictionary given a sequence of keys.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The dictionary in which to set the value.</p> required <code>keys</code> <code>list</code> <p>A list of keys representing the path to the nested value.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required Note <p>The function navigates through the dictionary using the keys and sets the value at the position indicated by the last key in the list.</p> Source code in <code>dataedit/helper.py</code> <pre><code>def set_nested_value(metadata, keys, value):\n    \"\"\"\n    Set a nested value in a dictionary given a sequence of keys.\n\n    Args:\n        metadata (dict): The dictionary in which to set the value.\n        keys (list): A list of keys representing the path to the nested value.\n        value (Any): The value to set.\n\n    Note:\n        The function navigates through the dictionary using the keys and sets the value\n        at the position indicated by the last key in the list.\n    \"\"\"\n\n    for key in keys[:-1]:\n        if key.isdigit():\n            key = int(key)\n        metadata = metadata[key]\n    last_key = keys[-1]\n    if last_key.isdigit():\n        last_key = int(last_key)\n    metadata[last_key] = value\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#metadata-functions","title":"Metadata Functions","text":"<p>Provide functionality that is related to retrieving and updating the oemetadata resource from the database. The oemetadata is the object of a review.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#save-metadata-to-database","title":"Save Metadata to Database","text":"<p>Save updated metadata for a specific table in the OEP database.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The name of the OEP schema.</p> required <code>table</code> <code>str</code> <p>The name of the table in the OEP schema.</p> required <code>updated_metadata</code> <code>dict</code> <p>The updated metadata dictionary.</p> required Note <p>This function loads the table object from the database, updates its metadata field, and then saves the updated table object back to the database.</p> Source code in <code>dataedit/metadata/__init__.py</code> <pre><code>def save_metadata_to_db(schema, table, updated_metadata):\n    \"\"\"\n    Save updated metadata for a specific table in the OEP database.\n\n    Args:\n        schema (str): The name of the OEP schema.\n        table (str): The name of the table in the OEP schema.\n        updated_metadata (dict): The updated metadata dictionary.\n\n    Note:\n        This function loads the table object from the database,\n        updates its metadata field, and then saves the updated\n        table object back to the database.\n    \"\"\"\n\n    from dataedit.models import Table\n\n    # Load the table object\n    table_obj = Table.load(schema=schema, table=table)\n\n    # Update the oemetadata field\n    table_obj.oemetadata = updated_metadata\n\n    # Save the updated table object\n    table_obj.save()\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#load-metadata-from-database","title":"Load Metadata from Database","text":"<p>Load metadata for a specific table from the OEP database.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The name of the OEP schema.</p> required <code>table</code> <code>str</code> <p>The name of the table in the OEP schema.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The loaded metadata dictionary.</p> Note <p>The function currently loads metadata from the Table.oemetadata field. There is a consideration to change this function to use a different approach or keep the old functionality (TODO).</p> Source code in <code>dataedit/metadata/__init__.py</code> <pre><code>def load_metadata_from_db(schema, table):\n    \"\"\"\n    Load metadata for a specific table from the OEP database.\n\n    Args:\n        schema (str): The name of the OEP schema.\n        table (str): The name of the table in the OEP schema.\n\n    Returns:\n        dict: The loaded metadata dictionary.\n\n    Note:\n        The function currently loads metadata from the Table.oemetadata field.\n        There is a consideration to change this function to use a different approach\n        or keep the old functionality (TODO).\n    \"\"\"\n\n    from dataedit.models import Table\n\n    metadata = Table.load(schema=schema, table=table).oemetadata\n\n    metadata = parse_meta_data(metadata, schema, table)\n    return metadata\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#models","title":"Models","text":"<p>Django models.</p>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#peerreview","title":"PeerReview","text":"<p>The model of the Open Peer Review defines what data is stored in the django database about each existing review. Next to the review itself it stores additional data about the the reviewer and contributor user and more. It is used in the PeerReviewManger.</p> <p>Note</p> <p>This model also provides functionality that is directly related to the model. It is up to discussion if we want to keep the functionality inside the model.</p> <p>               Bases: <code>Model</code></p> <p>Represents a peer review in the database.</p> <p>Attributes:</p> Name Type Description <code>table</code> <code>CharField</code> <p>Name of the table being reviewed.</p> <code>schema</code> <code>CharField</code> <p>Name of the schema where the table is located.</p> <code>reviewer</code> <code>ForeignKey</code> <p>The user who reviews.</p> <code>contributor</code> <code>ForeignKey</code> <p>The user who contributes.</p> <code>is_finished</code> <code>BooleanField</code> <p>Whether the review is finished.</p> <code>date_started</code> <code>DateTimeField</code> <p>When the review started.</p> <code>date_submitted</code> <code>DateTimeField</code> <p>When the review was submitted.</p> <code>date_finished</code> <code>DateTimeField</code> <p>When the review finished.</p> <code>review</code> <code>JSONField</code> <p>The review data in JSON format.</p> Source code in <code>dataedit/models.py</code> <pre><code>class PeerReview(models.Model):\n    \"\"\"\n    Represents a peer review in the database.\n\n    Attributes:\n        table (CharField): Name of the table being reviewed.\n        schema (CharField): Name of the schema where the table is located.\n        reviewer (ForeignKey): The user who reviews.\n        contributor (ForeignKey): The user who contributes.\n        is_finished (BooleanField): Whether the review is finished.\n        date_started (DateTimeField): When the review started.\n        date_submitted (DateTimeField): When the review was submitted.\n        date_finished (DateTimeField): When the review finished.\n        review (JSONField): The review data in JSON format.\n    \"\"\"\n\n    table = CharField(max_length=1000, null=False)\n    schema = CharField(max_length=1000, null=False)\n    reviewer = ForeignKey(\n        \"login.myuser\", on_delete=models.CASCADE, related_name=\"reviewed_by\", null=True\n    )\n    contributor = ForeignKey(\n        \"login.myuser\",\n        on_delete=models.CASCADE,\n        related_name=\"review_received\",\n        null=True,\n    )\n    is_finished = BooleanField(null=False, default=False)\n    date_started = DateTimeField(max_length=1000, null=False, default=timezone.now)\n    date_submitted = DateTimeField(max_length=1000, null=True, default=None)\n    date_finished = DateTimeField(max_length=1000, null=True, default=None)\n    review = JSONField(null=True)\n    # TODO: Maybe oemetadata should be stored in a separate table and imported\n    # via FK here / change also for Tables model\n    oemetadata = JSONField(null=False, default=dict)\n\n    # laden\n    @classmethod\n    def load(cls, schema, table):\n        \"\"\"\n        Load the current reviewer user.\n        The current review is review is determened by the latest date started.\n\n        Args:\n            schema (string): Schema name\n            table (string): Table name\n\n        Returns:\n            opr (PeerReview): PeerReview object related to the latest\n            date started.\n        \"\"\"\n        opr = (\n            PeerReview.objects.filter(table=table, schema=schema)\n            .order_by(\"-date_started\")\n            .first()\n        )\n        return opr\n\n    # TODO: CAUTION unfinished work ... fix: includes all id\u00b4s and not just the\n    # related ones (reviews on same table) .. procedures false results\n    def get_prev_and_next_reviews(self, schema, table):\n        \"\"\"\n        Sets the prev_review and next_review fields based on the date_started\n        field of the PeerReview objects associated with the same table.\n        \"\"\"\n        # Get all the PeerReview objects associated with the same schema\n        # and table name\n        peer_reviews = PeerReview.objects.filter(table=table, schema=schema).order_by(\n            \"date_started\"\n        )\n\n        current_index = None\n        for index, review in enumerate(peer_reviews):\n            if review.id == self.id:\n                current_index = index\n                break\n\n        prev_review = None\n        next_review = None\n\n        if current_index is not None:\n            if current_index &gt; 0:\n                prev_review = peer_reviews[current_index - 1]\n\n            if current_index &lt; len(peer_reviews) - 1:\n                next_review = peer_reviews[current_index + 1]\n\n        return prev_review, next_review\n\n    def save(self, *args, **kwargs):\n        review_type = kwargs.pop(\"review_type\", None)\n        pm_new = None\n\n        if not self.contributor == self.reviewer:\n            super().save(*args, **kwargs)\n            # TODO: This causes errors if review list ist empty\n            # prev_review, next_review = self.get_prev_and_next_reviews(\n            #   self.schema, self.table\n            # )\n\n            # print(prev_review.id, next_review)\n            # print(prev_review, next_review)\n            # Create a new PeerReviewManager entry for this PeerReview\n            # pm_new = PeerReviewManager(opr=self, prev_review=prev_review)\n\n            if review_type == \"save\":\n                pm_new = PeerReviewManager(\n                    opr=self, status=ReviewDataStatus.SAVED.value\n                )\n\n            elif review_type == \"submit\":\n                result = self.set_version_of_metadata_for_review(\n                    schema=self.schema, table=self.table\n                )\n                if result[0]:\n                    logging.info(result[1])\n                elif result[0] is False:\n                    logging.info(result[1])\n\n                pm_new = PeerReviewManager(\n                    opr=self, status=ReviewDataStatus.SUBMITTED.value\n                )\n                pm_new.set_next_reviewer()\n\n            elif review_type == \"finished\":\n                result = self.set_version_of_metadata_for_review(\n                    schema=self.schema, table=self.table\n                )\n                if result[0]:\n                    logging.info(result[1])\n                elif result[0] is False:\n                    logging.info(result[1])\n\n                pm_new = PeerReviewManager(\n                    opr=self, status=ReviewDataStatus.FINISHED.value\n                )\n                self.is_finished = True\n                self.date_finished = timezone.now()\n                super().save(*args, **kwargs)\n\n            if pm_new:\n                pm_new.save()\n\n        else:\n            raise ValidationError(\"Contributor and reviewer cannot be the same.\")\n\n    def update(self, *args, **kwargs):\n        \"\"\"\n        Update the peer review if the latest peer review is not finished yet\n        but either saved or submitted.\n\n        \"\"\"\n\n        review_type = kwargs.pop(\"review_type\", None)\n        if not self.contributor == self.reviewer:\n            current_pm = PeerReviewManager.load(opr=self)\n            if review_type == \"save\":\n                current_pm.status = ReviewDataStatus.SAVED.value\n            elif review_type == \"submit\":\n                current_pm.status = ReviewDataStatus.SUBMITTED.value\n                current_pm.set_next_reviewer()\n            elif review_type == \"finished\":\n                self.is_finished = True\n                self.date_finished = timezone.now()\n                current_pm.status = ReviewDataStatus.FINISHED.value\n\n            # update peere review manager related to this peer review entry\n            current_pm.save()\n            super().save(*args, **kwargs)\n        else:\n            raise ValidationError(\"Contributor and reviewer cannot be the same.\")\n\n    def set_version_of_metadata_for_review(self, table, schema, *args, **kwargs):\n        \"\"\"\n        Once the peer review is started, we save the current version of the\n        oemetadata that is present on the table to the peer review instance\n        to be able to do the review to a fixed state of the metadata.\n\n        A started review means a reviewer saves / submits or finishes (in case\n        the review is completed in one go) a review.\n\n        Args:\n            table (str): Table name\n            schema (str): Table database schema aka data topic\n\n        Returns:\n            State (tuple): Bool value that indicates weather there is already\n            a version of oemetadata available for this review &amp; readable\n            status message.\n        \"\"\"\n        table_oemetdata = Table.load(schema=schema, table=table).oemetadata\n\n        if self.oemetadata is None:\n            self.oemetadata = table_oemetdata\n            super().save(*args, **kwargs)\n\n            return (\n                True,\n                f\"Set current version of table's: '{table}' oemetadata for review.\",\n            )\n\n        return (\n            False,\n            f\"This tables (name: {table}) review already got a version of oemetadata.\",\n        )\n\n    def update_all_table_peer_reviews_after_table_moved(\n        self, *args, to_schema, **kwargs\n    ):\n        # all_peer_reviews = self.objects.filter(table=table, schema=from_schema)\n        # for peer_review in all_peer_reviews:\n        if isinstance(self.review, str):\n            review_data = json.loads(self.review)\n        else:\n            review_data = self.review\n\n        review_data[\"topic\"] = to_schema\n\n        self.review = review_data\n        self.schema = to_schema\n\n        super().save(*args, **kwargs)\n\n    @property\n    def days_open(self):\n        if self.date_started is None:\n            return None  # Review has not started yet\n        elif self.is_finished:\n            return (self.date_finished - self.date_started).days  # Review has finished\n        else:\n            return (timezone.now() - self.date_started).days  # Review is still open\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReview.get_prev_and_next_reviews","title":"<code>get_prev_and_next_reviews(schema, table)</code>","text":"<p>Sets the prev_review and next_review fields based on the date_started field of the PeerReview objects associated with the same table.</p> Source code in <code>dataedit/models.py</code> <pre><code>def get_prev_and_next_reviews(self, schema, table):\n    \"\"\"\n    Sets the prev_review and next_review fields based on the date_started\n    field of the PeerReview objects associated with the same table.\n    \"\"\"\n    # Get all the PeerReview objects associated with the same schema\n    # and table name\n    peer_reviews = PeerReview.objects.filter(table=table, schema=schema).order_by(\n        \"date_started\"\n    )\n\n    current_index = None\n    for index, review in enumerate(peer_reviews):\n        if review.id == self.id:\n            current_index = index\n            break\n\n    prev_review = None\n    next_review = None\n\n    if current_index is not None:\n        if current_index &gt; 0:\n            prev_review = peer_reviews[current_index - 1]\n\n        if current_index &lt; len(peer_reviews) - 1:\n            next_review = peer_reviews[current_index + 1]\n\n    return prev_review, next_review\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReview.load","title":"<code>load(schema, table)</code>  <code>classmethod</code>","text":"<p>Load the current reviewer user. The current review is review is determened by the latest date started.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>string</code> <p>Schema name</p> required <code>table</code> <code>string</code> <p>Table name</p> required <p>Returns:</p> Name Type Description <code>opr</code> <code>PeerReview</code> <p>PeerReview object related to the latest</p> <p>date started.</p> Source code in <code>dataedit/models.py</code> <pre><code>@classmethod\ndef load(cls, schema, table):\n    \"\"\"\n    Load the current reviewer user.\n    The current review is review is determened by the latest date started.\n\n    Args:\n        schema (string): Schema name\n        table (string): Table name\n\n    Returns:\n        opr (PeerReview): PeerReview object related to the latest\n        date started.\n    \"\"\"\n    opr = (\n        PeerReview.objects.filter(table=table, schema=schema)\n        .order_by(\"-date_started\")\n        .first()\n    )\n    return opr\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReview.set_version_of_metadata_for_review","title":"<code>set_version_of_metadata_for_review(table, schema, *args, **kwargs)</code>","text":"<p>Once the peer review is started, we save the current version of the oemetadata that is present on the table to the peer review instance to be able to do the review to a fixed state of the metadata.</p> <p>A started review means a reviewer saves / submits or finishes (in case the review is completed in one go) a review.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Table name</p> required <code>schema</code> <code>str</code> <p>Table database schema aka data topic</p> required <p>Returns:</p> Name Type Description <code>State</code> <code>tuple</code> <p>Bool value that indicates weather there is already</p> <p>a version of oemetadata available for this review &amp; readable</p> <p>status message.</p> Source code in <code>dataedit/models.py</code> <pre><code>def set_version_of_metadata_for_review(self, table, schema, *args, **kwargs):\n    \"\"\"\n    Once the peer review is started, we save the current version of the\n    oemetadata that is present on the table to the peer review instance\n    to be able to do the review to a fixed state of the metadata.\n\n    A started review means a reviewer saves / submits or finishes (in case\n    the review is completed in one go) a review.\n\n    Args:\n        table (str): Table name\n        schema (str): Table database schema aka data topic\n\n    Returns:\n        State (tuple): Bool value that indicates weather there is already\n        a version of oemetadata available for this review &amp; readable\n        status message.\n    \"\"\"\n    table_oemetdata = Table.load(schema=schema, table=table).oemetadata\n\n    if self.oemetadata is None:\n        self.oemetadata = table_oemetdata\n        super().save(*args, **kwargs)\n\n        return (\n            True,\n            f\"Set current version of table's: '{table}' oemetadata for review.\",\n        )\n\n    return (\n        False,\n        f\"This tables (name: {table}) review already got a version of oemetadata.\",\n    )\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReview.update","title":"<code>update(*args, **kwargs)</code>","text":"<p>Update the peer review if the latest peer review is not finished yet but either saved or submitted.</p> Source code in <code>dataedit/models.py</code> <pre><code>def update(self, *args, **kwargs):\n    \"\"\"\n    Update the peer review if the latest peer review is not finished yet\n    but either saved or submitted.\n\n    \"\"\"\n\n    review_type = kwargs.pop(\"review_type\", None)\n    if not self.contributor == self.reviewer:\n        current_pm = PeerReviewManager.load(opr=self)\n        if review_type == \"save\":\n            current_pm.status = ReviewDataStatus.SAVED.value\n        elif review_type == \"submit\":\n            current_pm.status = ReviewDataStatus.SUBMITTED.value\n            current_pm.set_next_reviewer()\n        elif review_type == \"finished\":\n            self.is_finished = True\n            self.date_finished = timezone.now()\n            current_pm.status = ReviewDataStatus.FINISHED.value\n\n        # update peere review manager related to this peer review entry\n        current_pm.save()\n        super().save(*args, **kwargs)\n    else:\n        raise ValidationError(\"Contributor and reviewer cannot be the same.\")\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#peerreviewmanager","title":"PeerReviewManager","text":"<p>The Manager is introduced to be able to store additional information about the peer review process and separate it from the PeerReview model. The process is started by submitting a review and the manager maintains the order of which user has to take the next action to be able to hold and activate the process.</p> <p>Note</p> <p>This model also provides functionality that is directly related to the model. It is up to discussion if we want to keep the functionality inside the model.</p> <p>               Bases: <code>Model</code></p> <p>Manages peer review processes.</p> <p>This model handles the 1:n relation between table and open peer reviews. It tracks the days open for the peer review and its state. It determines who is next in the process between reviewer and contributor. It provides information about the previous and next review. It offers several methods that provide generic filters for the peer reviews.</p> <p>Attributes:</p> Name Type Description <code>opr</code> <code>ForeignKey</code> <p>The associated peer review.</p> <code>current_reviewer</code> <code>CharField</code> <p>The current reviewer.</p> <code>status</code> <code>CharField</code> <p>The current status of the review.</p> <code>is_open_since</code> <code>CharField</code> <p>How long the review has been open.</p> <code>prev_review</code> <code>ForeignKey</code> <p>The previous review in the process.</p> <code>next_review</code> <code>ForeignKey</code> <p>The next review in the process.</p> Source code in <code>dataedit/models.py</code> <pre><code>class PeerReviewManager(models.Model):\n    \"\"\"\n    Manages peer review processes.\n\n    This model handles the 1:n relation between table and open peer reviews.\n    It tracks the days open for the peer review and its state.\n    It determines who is next in the process between reviewer and contributor.\n    It provides information about the previous and next review.\n    It offers several methods that provide generic filters for the peer reviews.\n\n    Attributes:\n        opr (ForeignKey): The associated peer review.\n        current_reviewer (CharField): The current reviewer.\n        status (CharField): The current status of the review.\n        is_open_since (CharField): How long the review has been open.\n        prev_review (ForeignKey): The previous review in the process.\n        next_review (ForeignKey): The next review in the process.\n    \"\"\"\n\n    REVIEW_STATUS = [(status.value, status.name) for status in ReviewDataStatus]\n    REVIEWER_CHOICES = [(choice.value, choice.name) for choice in Reviewer]\n\n    opr = ForeignKey(\n        PeerReview, on_delete=models.CASCADE, related_name=\"review_id\", null=False\n    )\n    current_reviewer = models.CharField(\n        choices=REVIEWER_CHOICES, max_length=20, default=Reviewer.REVIEWER.value\n    )\n    status = models.CharField(\n        choices=REVIEW_STATUS, max_length=10, default=ReviewDataStatus.SAVED.value\n    )\n    is_open_since = models.CharField(null=True, max_length=10)\n    prev_review = ForeignKey(\n        PeerReview,\n        on_delete=models.CASCADE,\n        related_name=\"prev_review\",\n        null=True,\n        default=None,\n    )  # TODO: add logic\n    next_review = ForeignKey(\n        PeerReview,\n        on_delete=models.CASCADE,\n        related_name=\"next_review\",\n        null=True,\n        default=None,\n    )  # TODO: add logic\n\n    @classmethod\n    def load(cls, opr):\n        \"\"\"\n        Load the peer review manager associated with the given peer review.\n\n        Args:\n            opr (PeerReview): The peer review.\n\n        Returns:\n            PeerReviewManager: The peer review manager.\n        \"\"\"\n        peer_review_manager = PeerReviewManager.objects.get(opr=opr)\n        return peer_review_manager\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        Override the save method to perform additional logic\n        before saving the peer review manager.\n        \"\"\"\n        # Set is_open_since field if it is None\n        if self.is_open_since is None:\n            # Get the associated PeerReview instance\n            peer_review = self.opr\n\n            # Set is_open_since based on the days_open property of the\n            # PeerReview instance\n            days_open = peer_review.days_open\n            if days_open is not None:\n                self.is_open_since = str(days_open)\n        # print(self.is_open_since, self.status)\n        # Call the parent class's save method to save the PeerReviewManager instance\n        super().save(*args, **kwargs)\n\n    @classmethod\n    def update_open_since(cls, opr=None, *args, **kwargs):\n        \"\"\"\n        Update the \"is_open_since\" field of the peer review manager.\n\n        Args:\n            opr (PeerReview): The peer review.\n            If None, use the peer review associated with the manager.\n\n        \"\"\"\n        if opr is not None:\n            peer_review = PeerReviewManager.objects.get(opr=opr)\n        else:\n            peer_review = cls.opr\n\n        days_open = peer_review.opr.days_open\n        peer_review.is_open_since = str(days_open)\n\n        # Call the parent class's save method to save the PeerReviewManager instance\n        peer_review.save(*args, **kwargs)\n\n    def set_next_reviewer(self):\n        \"\"\"\n        Set the order on which peer will be required to perform a action to\n        continue with the process.\n        \"\"\"\n        # TODO:check for user identifies as ...\n        if self.current_reviewer == Reviewer.REVIEWER.value:\n            self.current_reviewer = Reviewer.CONTRIBUTOR.value\n        else:\n            self.current_reviewer = Reviewer.REVIEWER.value\n        self.save()\n\n    def whos_turn(self):\n        \"\"\"\n        Get the user and role (contributor or reviewer) whose turn it is.\n\n        Returns:\n            Tuple[str, User]: The role and user.\n        \"\"\"\n        role, result = None, None\n        peer_review = self.opr\n        if self.current_reviewer == Reviewer.REVIEWER.value:\n            role = Reviewer.REVIEWER.value\n            result = peer_review.reviewer\n        else:\n            role = Reviewer.CONTRIBUTOR.value\n            result = peer_review.contributor\n\n        return role, result\n\n    @staticmethod\n    def load_contributor(schema, table):\n        \"\"\"\n        Get the contributor for the table a review is started.\n\n        Args:\n            schema (str): Schema name.\n            table (str): Table name.\n\n        Returns:\n            User: The contributor user.\n        \"\"\"\n        current_table = Table.load(schema=schema, table=table)\n        try:\n            table_holder = (\n                current_table.userpermission_set.filter(table=current_table.id)\n                .first()\n                .holder\n            )\n        except AttributeError:\n            table_holder = None\n        return table_holder\n\n    @staticmethod\n    def load_reviewer(schema, table):\n        \"\"\"\n            Get the reviewer for the table a review is started.\n        .\n            Args:\n                schema (str): Schema name.\n                table (str): Table name.\n\n            Returns:\n                User: The reviewer user.\n        \"\"\"\n        current_review = PeerReview.load(schema=schema, table=table)\n        if current_review and hasattr(current_review, \"reviewer\"):\n            return current_review.reviewer\n        else:\n            return None\n\n    @staticmethod\n    def filter_opr_by_reviewer(reviewer_user):\n        \"\"\"\n        Filter peer reviews by reviewer, excluding those with current peer\n        is contributor and the data status \"SAVED\" in the peer review manager.\n\n        Args:\n            reviewer_user (User): The reviewer user.\n\n        Returns:\n            QuerySet: Filtered peer reviews.\n        \"\"\"\n        return PeerReview.objects.filter(reviewer=reviewer_user).exclude(\n            review_id__current_reviewer=Reviewer.CONTRIBUTOR.value,\n            review_id__status=ReviewDataStatus.SAVED.value,\n        )\n\n    @staticmethod\n    def filter_latest_open_opr_by_reviewer(reviewer_user):\n        \"\"\"\n        Get the last open peer review for the given contributor.\n\n        Args:\n            contributor_user (User): The contributor user.\n\n        Returns:\n            PeerReview: Last open peer review or None if not found.\n        \"\"\"\n        try:\n            return (\n                PeerReview.objects.filter(reviewer=reviewer_user, is_finished=False)\n                .exclude(\n                    review_id__current_reviewer=Reviewer.CONTRIBUTOR.value,\n                    review_id__status=ReviewDataStatus.SAVED.value,\n                )\n                .latest(\"date_started\")\n            )\n        except PeerReview.DoesNotExist:\n            return None\n\n    @staticmethod\n    def filter_opr_by_contributor(contributor_user):\n        \"\"\"\n        Filter peer reviews by contributor, excluding those with current peer\n        is reviewer and the data status \"SAVED\" in the peer review manager.\n\n        Args:\n            contributor_user (User): The contributor user.\n\n        Returns:\n            QuerySet: Filtered peer reviews.\n        \"\"\"\n\n        return PeerReview.objects.filter(contributor=contributor_user).exclude(\n            review_id__current_reviewer=Reviewer.REVIEWER.value,\n            review_id__status=ReviewDataStatus.SAVED.value,\n        )\n\n    @staticmethod\n    def filter_latest_open_opr_by_contributor(contributor_user):\n        \"\"\"\n        Get the last open peer review for the given contributor.\n\n        Args:\n            contributor_user (User): The contributor user.\n\n        Returns:\n            PeerReview: Last open peer review or None if not found.\n        \"\"\"\n        try:\n            return (\n                PeerReview.objects.filter(\n                    contributor=contributor_user, is_finished=False\n                )\n                .exclude(\n                    review_id__current_reviewer=Reviewer.REVIEWER.value,\n                    review_id__status=ReviewDataStatus.SAVED.value,\n                )\n                .latest(\"date_started\")\n            )\n        except PeerReview.DoesNotExist:\n            return None\n\n    @staticmethod\n    def filter_opr_by_table(schema, table):\n        \"\"\"\n        Filter peer reviews by schema and table.\n\n        Args:\n            schema (str): Schema name.\n            table (str): Table name.\n\n        Returns:\n            QuerySet: Filtered peer reviews.\n        \"\"\"\n        return PeerReview.objects.filter(schema=schema, table=table)\n\n    def filter_opr_by_id(opr_id):\n        return PeerReview.objects.filter(id=opr_id).first()\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.filter_latest_open_opr_by_contributor","title":"<code>filter_latest_open_opr_by_contributor(contributor_user)</code>  <code>staticmethod</code>","text":"<p>Get the last open peer review for the given contributor.</p> <p>Parameters:</p> Name Type Description Default <code>contributor_user</code> <code>User</code> <p>The contributor user.</p> required <p>Returns:</p> Name Type Description <code>PeerReview</code> <p>Last open peer review or None if not found.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef filter_latest_open_opr_by_contributor(contributor_user):\n    \"\"\"\n    Get the last open peer review for the given contributor.\n\n    Args:\n        contributor_user (User): The contributor user.\n\n    Returns:\n        PeerReview: Last open peer review or None if not found.\n    \"\"\"\n    try:\n        return (\n            PeerReview.objects.filter(\n                contributor=contributor_user, is_finished=False\n            )\n            .exclude(\n                review_id__current_reviewer=Reviewer.REVIEWER.value,\n                review_id__status=ReviewDataStatus.SAVED.value,\n            )\n            .latest(\"date_started\")\n        )\n    except PeerReview.DoesNotExist:\n        return None\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.filter_latest_open_opr_by_reviewer","title":"<code>filter_latest_open_opr_by_reviewer(reviewer_user)</code>  <code>staticmethod</code>","text":"<p>Get the last open peer review for the given contributor.</p> <p>Parameters:</p> Name Type Description Default <code>contributor_user</code> <code>User</code> <p>The contributor user.</p> required <p>Returns:</p> Name Type Description <code>PeerReview</code> <p>Last open peer review or None if not found.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef filter_latest_open_opr_by_reviewer(reviewer_user):\n    \"\"\"\n    Get the last open peer review for the given contributor.\n\n    Args:\n        contributor_user (User): The contributor user.\n\n    Returns:\n        PeerReview: Last open peer review or None if not found.\n    \"\"\"\n    try:\n        return (\n            PeerReview.objects.filter(reviewer=reviewer_user, is_finished=False)\n            .exclude(\n                review_id__current_reviewer=Reviewer.CONTRIBUTOR.value,\n                review_id__status=ReviewDataStatus.SAVED.value,\n            )\n            .latest(\"date_started\")\n        )\n    except PeerReview.DoesNotExist:\n        return None\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.filter_opr_by_contributor","title":"<code>filter_opr_by_contributor(contributor_user)</code>  <code>staticmethod</code>","text":"<p>Filter peer reviews by contributor, excluding those with current peer is reviewer and the data status \"SAVED\" in the peer review manager.</p> <p>Parameters:</p> Name Type Description Default <code>contributor_user</code> <code>User</code> <p>The contributor user.</p> required <p>Returns:</p> Name Type Description <code>QuerySet</code> <p>Filtered peer reviews.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef filter_opr_by_contributor(contributor_user):\n    \"\"\"\n    Filter peer reviews by contributor, excluding those with current peer\n    is reviewer and the data status \"SAVED\" in the peer review manager.\n\n    Args:\n        contributor_user (User): The contributor user.\n\n    Returns:\n        QuerySet: Filtered peer reviews.\n    \"\"\"\n\n    return PeerReview.objects.filter(contributor=contributor_user).exclude(\n        review_id__current_reviewer=Reviewer.REVIEWER.value,\n        review_id__status=ReviewDataStatus.SAVED.value,\n    )\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.filter_opr_by_reviewer","title":"<code>filter_opr_by_reviewer(reviewer_user)</code>  <code>staticmethod</code>","text":"<p>Filter peer reviews by reviewer, excluding those with current peer is contributor and the data status \"SAVED\" in the peer review manager.</p> <p>Parameters:</p> Name Type Description Default <code>reviewer_user</code> <code>User</code> <p>The reviewer user.</p> required <p>Returns:</p> Name Type Description <code>QuerySet</code> <p>Filtered peer reviews.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef filter_opr_by_reviewer(reviewer_user):\n    \"\"\"\n    Filter peer reviews by reviewer, excluding those with current peer\n    is contributor and the data status \"SAVED\" in the peer review manager.\n\n    Args:\n        reviewer_user (User): The reviewer user.\n\n    Returns:\n        QuerySet: Filtered peer reviews.\n    \"\"\"\n    return PeerReview.objects.filter(reviewer=reviewer_user).exclude(\n        review_id__current_reviewer=Reviewer.CONTRIBUTOR.value,\n        review_id__status=ReviewDataStatus.SAVED.value,\n    )\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.filter_opr_by_table","title":"<code>filter_opr_by_table(schema, table)</code>  <code>staticmethod</code>","text":"<p>Filter peer reviews by schema and table.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>Schema name.</p> required <code>table</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Name Type Description <code>QuerySet</code> <p>Filtered peer reviews.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef filter_opr_by_table(schema, table):\n    \"\"\"\n    Filter peer reviews by schema and table.\n\n    Args:\n        schema (str): Schema name.\n        table (str): Table name.\n\n    Returns:\n        QuerySet: Filtered peer reviews.\n    \"\"\"\n    return PeerReview.objects.filter(schema=schema, table=table)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.load","title":"<code>load(opr)</code>  <code>classmethod</code>","text":"<p>Load the peer review manager associated with the given peer review.</p> <p>Parameters:</p> Name Type Description Default <code>opr</code> <code>PeerReview</code> <p>The peer review.</p> required <p>Returns:</p> Name Type Description <code>PeerReviewManager</code> <p>The peer review manager.</p> Source code in <code>dataedit/models.py</code> <pre><code>@classmethod\ndef load(cls, opr):\n    \"\"\"\n    Load the peer review manager associated with the given peer review.\n\n    Args:\n        opr (PeerReview): The peer review.\n\n    Returns:\n        PeerReviewManager: The peer review manager.\n    \"\"\"\n    peer_review_manager = PeerReviewManager.objects.get(opr=opr)\n    return peer_review_manager\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.load_contributor","title":"<code>load_contributor(schema, table)</code>  <code>staticmethod</code>","text":"<p>Get the contributor for the table a review is started.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>Schema name.</p> required <code>table</code> <code>str</code> <p>Table name.</p> required <p>Returns:</p> Name Type Description <code>User</code> <p>The contributor user.</p> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef load_contributor(schema, table):\n    \"\"\"\n    Get the contributor for the table a review is started.\n\n    Args:\n        schema (str): Schema name.\n        table (str): Table name.\n\n    Returns:\n        User: The contributor user.\n    \"\"\"\n    current_table = Table.load(schema=schema, table=table)\n    try:\n        table_holder = (\n            current_table.userpermission_set.filter(table=current_table.id)\n            .first()\n            .holder\n        )\n    except AttributeError:\n        table_holder = None\n    return table_holder\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.load_reviewer","title":"<code>load_reviewer(schema, table)</code>  <code>staticmethod</code>","text":"<pre><code>Get the reviewer for the table a review is started.\n</code></pre> <p>.     Args:         schema (str): Schema name.         table (str): Table name.</p> <pre><code>Returns:\n    User: The reviewer user.\n</code></pre> Source code in <code>dataedit/models.py</code> <pre><code>@staticmethod\ndef load_reviewer(schema, table):\n    \"\"\"\n        Get the reviewer for the table a review is started.\n    .\n        Args:\n            schema (str): Schema name.\n            table (str): Table name.\n\n        Returns:\n            User: The reviewer user.\n    \"\"\"\n    current_review = PeerReview.load(schema=schema, table=table)\n    if current_review and hasattr(current_review, \"reviewer\"):\n        return current_review.reviewer\n    else:\n        return None\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>Override the save method to perform additional logic before saving the peer review manager.</p> Source code in <code>dataedit/models.py</code> <pre><code>def save(self, *args, **kwargs):\n    \"\"\"\n    Override the save method to perform additional logic\n    before saving the peer review manager.\n    \"\"\"\n    # Set is_open_since field if it is None\n    if self.is_open_since is None:\n        # Get the associated PeerReview instance\n        peer_review = self.opr\n\n        # Set is_open_since based on the days_open property of the\n        # PeerReview instance\n        days_open = peer_review.days_open\n        if days_open is not None:\n            self.is_open_since = str(days_open)\n    # print(self.is_open_since, self.status)\n    # Call the parent class's save method to save the PeerReviewManager instance\n    super().save(*args, **kwargs)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.set_next_reviewer","title":"<code>set_next_reviewer()</code>","text":"<p>Set the order on which peer will be required to perform a action to continue with the process.</p> Source code in <code>dataedit/models.py</code> <pre><code>def set_next_reviewer(self):\n    \"\"\"\n    Set the order on which peer will be required to perform a action to\n    continue with the process.\n    \"\"\"\n    # TODO:check for user identifies as ...\n    if self.current_reviewer == Reviewer.REVIEWER.value:\n        self.current_reviewer = Reviewer.CONTRIBUTOR.value\n    else:\n        self.current_reviewer = Reviewer.REVIEWER.value\n    self.save()\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.update_open_since","title":"<code>update_open_since(opr=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Update the \"is_open_since\" field of the peer review manager.</p> <p>Parameters:</p> Name Type Description Default <code>opr</code> <code>PeerReview</code> <p>The peer review.</p> <code>None</code> Source code in <code>dataedit/models.py</code> <pre><code>@classmethod\ndef update_open_since(cls, opr=None, *args, **kwargs):\n    \"\"\"\n    Update the \"is_open_since\" field of the peer review manager.\n\n    Args:\n        opr (PeerReview): The peer review.\n        If None, use the peer review associated with the manager.\n\n    \"\"\"\n    if opr is not None:\n        peer_review = PeerReviewManager.objects.get(opr=opr)\n    else:\n        peer_review = cls.opr\n\n    days_open = peer_review.opr.days_open\n    peer_review.is_open_since = str(days_open)\n\n    # Call the parent class's save method to save the PeerReviewManager instance\n    peer_review.save(*args, **kwargs)\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/open-peer-review-process/technical-docs/#dataedit.models.PeerReviewManager.whos_turn","title":"<code>whos_turn()</code>","text":"<p>Get the user and role (contributor or reviewer) whose turn it is.</p> <p>Returns:</p> Type Description <p>Tuple[str, User]: The role and user.</p> Source code in <code>dataedit/models.py</code> <pre><code>def whos_turn(self):\n    \"\"\"\n    Get the user and role (contributor or reviewer) whose turn it is.\n\n    Returns:\n        Tuple[str, User]: The role and user.\n    \"\"\"\n    role, result = None, None\n    peer_review = self.opr\n    if self.current_reviewer == Reviewer.REVIEWER.value:\n        role = Reviewer.REVIEWER.value\n        result = peer_review.reviewer\n    else:\n        role = Reviewer.CONTRIBUTOR.value\n        result = peer_review.contributor\n\n    return role, result\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/","title":"Scenario Bundles feature","text":"<p>The scenario bundles feature is a response to the complex requirements for the transparent publication of scenarios in a complete and comprehensible manner. Various technologies are used to enable researchers to publish scenarios and any additional information. In addition, existing resources from the open energy platform are used and bundled together. This is intended to increase the visibility of available research work and enable comparability of the scenarios.</p>"},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/#what-are-scenario-bundles-in-detail","title":"What are Scenario Bundles in detail?","text":"<p>Please continue reading here.</p>"},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/#technologies","title":"Technologies","text":"<p>User Interface</p> <ul> <li>We offer a modern user interface developed with the REACT library.</li> </ul> <p>Backend &amp; Web-API</p> <ul> <li>We build on the backend of the Open Energy Platform and use Django to implement functionalities such as saving and deleting scenario bundles and thus enable communication with the database. In addition, Django provides the WEB-API endpoints that are used to create a scenario bundle or query the database using JSON requests, for example.</li> <li>A Python integration of the SPARQL query language is used to interact with the Grpah database.</li> </ul> <p>Database</p> <ul> <li>A graph database is used to store the complex data structure of the scenario bundles in the long term. We use Appache Jenna-Fuseki as a reliable technology.</li> </ul>"},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/#functionalities","title":"Functionalities","text":""},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/#code-documentation","title":"Code Documentation","text":""},{"location":"install-and-documentation/oeplatform-code/features/scenario-bundles/#django-view-for-the-scenario-bundles","title":"Django view for the scenario bundles","text":"<p>Note</p> <p>Some of the information on this page may be changed in the future. To review the most recent information, please revisit.</p> <p><code>def create_factsheet(request, *args, **kwargs):</code></p> <p>Creates a scenario bundle based on user's data. Currently, the minimum requirement to create a bundle is the \"acronym\". The \"acronym\" must be unique. If the provided acronym already exists in the OEKG, then the function returns a \"Duplicate error\".</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>uid</code> <code>str</code> <p>The unique ID for the bundle.</p> required <code>acronym</code> <code>str</code> <p>The acronym for the bundle.</p> required <code>abstract</code> <code>str</code> <p>The abstract for the bundle.</p> required <code>institution</code> <code>list of objects</code> <p>The institutions for the bundle.</p> required <code>funding_source</code> <code>list of objects</code> <p>The funding sources for the bundle.</p> required <code>contact_person</code> <code>list of objects</code> <p>The contact persons for the bundle.</p> required <code>sector_divisions</code> <code>list of objects</code> <p>The sector divisions for the bundle.</p> required <code>sectors</code> <code>list of objects</code> <p>The sectors for the bundle.</p> required <code>technologies</code> <code>list of objects</code> <p>The technologies for the bundle.</p> required <code>study_keywords</code> <code>list of strings</code> <p>The study keywords for the bundle.</p> required <code>scenarios</code> <code>list of objects</code> <p>The scenarios for the bundle.</p> required <code>models</code> <code>list of strings</code> <p>The models for the bundle.</p> required <code>frameworks</code> <code>list of strings</code> <p>The frameworks for the bundle.</p> required <code>publications</code> <code>list[object]</code> <p>A list of n publications related to the bundle study_name (str): The study name for the bundle. date_of_publication (str): The date of publication for the bundle. report_title (str): The report title for the bundle. report_doi (str): The report_doi for the bundle. place_of_publication (str): The place of publication for the bundle. link_to_study_report (str): The link to study for the bundle. authors (list of objects): The authors for the bundle.</p> required <p>Returns:</p> Type Description <p>\"Factsheet saved\" if successful, \"Duplicate error\" if the bundle's</p> <p>acronym exists.</p> Source code in <code>factsheet/views.py</code> <pre><code>def create_factsheet(request, *args, **kwargs):\n    \"\"\"\n    Creates a scenario bundle based on user's data. Currently, the minimum requirement\n    to create a bundle is the \"acronym\". The \"acronym\" must be unique. If the provided\n    acronym already exists in the OEKG, then the function returns a \"Duplicate error\".\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        uid (str): The unique ID for the bundle.\n        acronym (str): The acronym for the bundle.\n        abstract (str): The abstract for the bundle.\n        institution (list of objects): The institutions for the bundle.\n        funding_source (list of objects): The funding sources for the bundle.\n        contact_person (list of objects): The contact persons for the bundle.\n        sector_divisions (list of objects): The sector divisions for the bundle.\n        sectors (list of objects): The sectors for the bundle.\n        technologies (list of objects): The technologies for the bundle.\n        study_keywords (list of strings): The study keywords for the bundle.\n        scenarios (list of objects): The scenarios for the bundle.\n        models (list of strings): The models for the bundle.\n        frameworks (list of strings): The frameworks for the bundle.\n        publications (list[object]): A list of n publications related to the bundle\n            study_name (str): The study name for the bundle.\n            date_of_publication (str): The date of publication for the bundle.\n            report_title (str): The report title for the bundle.\n            report_doi (str): The report_doi for the bundle.\n            place_of_publication (str): The place of publication for the bundle.\n            link_to_study_report (str): The link to study for the bundle.\n            authors (list of objects): The authors for the bundle.\n\n    Returns:\n        \"Factsheet saved\" if successful, \"Duplicate error\" if the bundle's\n        acronym exists.\n\n    \"\"\"\n\n    if not request.user.is_authenticated:\n        return HttpResponseForbidden(\"User not authenticated\")\n\n    request_body = json.loads(request.body)\n    name = request_body[\"name\"]  # noqa\n    uid = request_body[\"uid\"]\n    acronym = (request_body[\"acronym\"])\n    study_name = request_body[\"study_name\"]\n    abstract = request_body[\"abstract\"]\n    institution = request_body[\"institution\"]\n    funding_source = request_body[\"funding_source\"]\n    contact_person = request_body[\"contact_person\"]\n    sector_divisions = request_body[\"sector_divisions\"]\n    sectors = request_body[\"sectors\"]\n    # expanded_sectors = request_body[\"expanded_sectors\"]  # noqa\n    # energy_carriers = request_body['energy_carriers']\n    # expanded_energy_carriers = request_body['expanded_energy_carriers']\n    # energy_transformation_processes = request_body['energy_transformation_processes']\n    # expanded_energy_transformation_processes = request_body['expanded_energy_transformation_processes'] # noqa\n    technologies = request_body[\"technologies\"]\n    study_keywords = request_body[\"study_keywords\"]\n    scenarios = request_body[\"scenarios\"]\n    publications = request_body[\"publications\"]\n    models = request_body[\"models\"]\n    frameworks = request_body[\"frameworks\"]\n\n    Duplicate_study_factsheet = False\n\n    for s, p, o in oekg.triples((None, RDF.type, OEO.OEO_00010252)):\n        study_acronym = oekg.value(s, DC.acronym)\n        if str(clean_name(acronym)) == str(study_acronym):\n            Duplicate_study_factsheet = True\n\n    if Duplicate_study_factsheet == True:  # noqa\n        response = JsonResponse(\n            \"Factsheet exists\", safe=False, content_type=\"application/json\"\n        )\n        patch_response_headers(response, cache_timeout=1)\n        return response\n    else:\n        bundle = Graph()\n\n        study_URI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + uid)\n        bundle.add((study_URI, RDF.type, OEO.OEO_00010252))\n\n        if acronym != \"\":\n            bundle.add((study_URI, DC.acronym, Literal(remove_non_printable(acronym))))\n        if study_name != \"\":\n            bundle.add((study_URI, OEKG[\"has_full_name\"], Literal(remove_non_printable(study_name))))\n        if abstract != \"\":\n            bundle.add((study_URI, DC.abstract, Literal(remove_non_printable(abstract))))\n\n        _publications = json.loads(publications) if publications is not None else []\n        for item in _publications:\n            publications_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/publication/\" + item[\"id\"]\n            )\n            bundle.add(\n                (publications_URI, OEKG[\"publication_uuid\"], Literal(remove_non_printable(item[\"id\"])))\n            )\n\n            bundle.add((study_URI, OEKG[\"has_publication\"], publications_URI))\n            if item[\"report_title\"] != \"\":\n                bundle.add(\n                    (publications_URI, RDFS.label, Literal(remove_non_printable(item[\"report_title\"])))\n                )\n\n            _authors = item[\"authors\"]\n            for author in _authors:\n                author_URI = URIRef(\n                    \"http://openenergy-platform.org/ontology/oekg/\" + author[\"iri\"]\n                )\n                bundle.add((publications_URI, OEO.OEO_00000506, author_URI))\n\n            if item[\"doi\"] != \"\":\n                bundle.add((publications_URI, OEKG[\"doi\"], Literal(remove_non_printable(item[\"doi\"]))))\n\n            if (\n                item[\"date_of_publication\"] != \"01-01-1900\"\n                and item[\"date_of_publication\"] != \"\"\n            ):\n                bundle.add(\n                    (\n                        publications_URI,\n                        OEKG[\"date_of_publication\"],\n                        Literal(remove_non_printable(item[\"date_of_publication\"])),\n                    )\n                )\n\n            if item[\"link_to_study_report\"] != \"\":\n                bundle.add(\n                    (\n                        publications_URI,\n                        OEKG[\"link_to_study_report\"],\n                        Literal(remove_non_printable(item[\"link_to_study_report\"])),\n                    )\n                )\n\n            bundle.add((study_URI, OEKG[\"has_publication\"], publications_URI))\n\n        _scenarios = json.loads(scenarios) if scenarios is not None else []\n        for item in _scenarios:\n            if item[\"acronym\"] != \"\":\n                # TODO- set in settings\n                scenario_URI = URIRef(\n                    \"http://openenergy-platform.org/ontology/oekg/scenario/\"\n                    + item[\"id\"]\n                )\n                bundle.add((study_URI, OEKG[\"has_scenario\"], scenario_URI))\n                bundle.add((scenario_URI, RDFS.label, Literal(remove_non_printable(item[\"acronym\"]))))\n                if item[\"name\"] != \"\":\n                    bundle.add(\n                        (scenario_URI, OEKG[\"has_full_name\"], Literal(remove_non_printable(item[\"name\"])))\n                    )\n                    bundle.add((scenario_URI, RDF.type, OEO.OEO_00000365))\n                if item[\"abstract\"] != \"\":\n                    bundle.add((scenario_URI, DC.abstract, Literal(remove_non_printable(item[\"abstract\"]))))\n\n                bundle.add((scenario_URI, OEKG[\"scenario_uuid\"], Literal(remove_non_printable(item[\"id\"]))))\n\n                if \"regions\" in item:\n                    for region in item[\"regions\"]:\n                        region_URI = URIRef(region[\"iri\"])\n                        scenario_region = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/region/\"\n                            + region[\"iri\"].rsplit(\"/\", 1)[1]\n                        )\n                        bundle.add((scenario_region, RDF.type, OEO.OEO_00020032))\n                        bundle.add(\n                            (scenario_region, RDFS.label, Literal(remove_non_printable(region[\"name\"])))\n                        )\n                        bundle.add((scenario_region, OEKG[\"reference\"], region_URI))\n                        bundle.add((scenario_URI, OEO.OEO_00020220, scenario_region))\n\n                if \"interacting_regions\" in item:\n                    for interacting_region in item[\"interacting_regions\"]:\n                        interacting_region_URI = URIRef(interacting_region[\"iri\"])\n                        scenario_interacting_region = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/\"\n                            + interacting_region[\"iri\"]\n                        )\n\n                        bundle.add(\n                            (scenario_interacting_region, RDF.type, OEO.OEO_00020036)\n                        )\n                        bundle.add(\n                            (\n                                scenario_interacting_region,\n                                RDFS.label,\n                                Literal(remove_non_printable(interacting_region[\"name\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                scenario_interacting_region,\n                                OEKG[\"reference\"],\n                                interacting_region_URI,\n                            )\n                        )\n                        bundle.add(\n                            (\n                                scenario_URI,\n                                OEO.OEO_00020222,\n                                scenario_interacting_region,\n                            )\n                        )\n\n                if \"scenario_years\" in item:\n                    for scenario_year in item[\"scenario_years\"]:\n                        bundle.add(\n                            (\n                                scenario_URI,\n                                OEO.OEO_00020224,\n                                Literal(remove_non_printable(scenario_year[\"name\"])),\n                            )\n                        )\n\n                if \"descriptors\" in item:\n                    for descriptor in item[\"descriptors\"]:\n                        descriptor = URIRef(descriptor[\"class\"])\n                        bundle.add(\n                            (scenario_URI, OEO[\"has_scenario_descriptor\"], descriptor)\n                        )\n\n                # TODO: jh-RLI: Update to avoid duplicated table name entries\n                if \"input_datasets\" in item:\n                    for input_dataset in item[\"input_datasets\"]:\n                        # TODO- set in settings\n                        input_dataset_URI = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/input_datasets/\"  # noqa\n                            + input_dataset[\"key\"]\n                        )\n                        bundle.add((input_dataset_URI, RDF.type, OEO.OEO_00030030))\n                        bundle.add(\n                            (\n                                input_dataset_URI,\n                                RDFS.label,\n                                Literal(remove_non_printable(input_dataset[\"value\"][\"label\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_iri\"],\n                                Literal(remove_non_printable(input_dataset[\"value\"][\"url\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_id\"],\n                                Literal(remove_non_printable(input_dataset[\"idx\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_key\"],\n                                Literal(remove_non_printable(input_dataset[\"key\"])),\n                            )\n                        )\n                        bundle.add((scenario_URI, OEO.RO_0002233, input_dataset_URI))\n\n                # TODO: jh-RLI: Update to avoid duplicated table name entries\n                if \"output_datasets\" in item:\n                    for output_dataset in item[\"output_datasets\"]:\n                        # TODO- set in settings\n                        output_dataset_URI = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/output_datasets/\"  # noqa\n                            + output_dataset[\"key\"]\n                        )\n                        bundle.add((output_dataset_URI, RDF.type, OEO.OEO_00030029))\n                        bundle.add(\n                            (\n                                output_dataset_URI,\n                                RDFS.label,\n                                Literal(remove_non_printable(output_dataset[\"value\"][\"label\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_iri\"],\n                                Literal(remove_non_printable(output_dataset[\"value\"][\"url\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_id\"],\n                                Literal(remove_non_printable(output_dataset[\"idx\"])),\n                            )\n                        )\n                        bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_key\"],\n                                Literal(remove_non_printable(output_dataset[\"key\"])),\n                            )\n                        )\n                        bundle.add((scenario_URI, OEO.RO_0002234, output_dataset_URI))\n\n        institutions = json.loads(institution) if institution is not None else []\n        for item in institutions:\n            institution_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            bundle.add((study_URI, OEO.OEO_00000510, institution_URI))\n\n        funding_sources = (\n            json.loads(funding_source) if funding_source is not None else []\n        )\n        for item in funding_sources:\n            funding_source_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            bundle.add((study_URI, OEO.OEO_00000509, funding_source_URI))\n        contact_persons = (\n            json.loads(contact_person) if contact_person is not None else []\n        )\n        for item in contact_persons:\n            contact_person_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            bundle.add((study_URI, OEO.OEO_00000508, contact_person_URI))\n\n        _sector_divisions = (\n            json.loads(sector_divisions) if sector_divisions is not None else []\n        )\n        for item in _sector_divisions:\n            sector_divisions_URI = URIRef(item[\"class\"])\n            bundle.add(\n                (study_URI, OEO[\"based_on_sector_division\"], sector_divisions_URI)\n            )\n\n        _sectors = json.loads(sectors) if sectors is not None else []\n        for item in _sectors:\n            sector_URI = URIRef(item[\"class\"])\n            bundle.add((study_URI, OEO.OEO_00000505, sector_URI))\n\n        _technologies = json.loads(technologies) if technologies is not None else []\n        for item in _technologies:\n            technology_URI = URIRef(item[\"class\"])\n            bundle.add((study_URI, OEO.OEO_00000522, technology_URI))\n\n        _models = json.loads(models) if models is not None else []\n        for item in _models:\n            model_id = item.get(\"id\")\n            if item.get(\"acronym\"):\n                model_acronym = item.get(\"acronym\")\n            else:\n                model_acronym = item.get(\"name\")\n            model_url = item.get(\"url\")\n\n            if not model_id or not model_acronym or not model_url:\n                continue  # Skip this item if any critical field is empty\n\n            model_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/models/\" + str(model_id)\n            )\n            bundle.add((model_URI, RDF.type, OEO.OEO_00000277))\n            bundle.add(\n                (\n                    model_URI,\n                    RDFS.label,\n                    Literal(remove_non_printable(model_acronym)),\n                )\n            )\n            bundle.add(\n                (\n                    model_URI,\n                    OEO[\"has_iri\"],\n                    Literal(remove_non_printable(model_url)),\n                )\n            )\n            bundle.add((study_URI, OEO[\"has_model\"], model_URI))\n\n        _frameworks = json.loads(frameworks) if frameworks is not None else []\n        for item in _frameworks:\n            framework_id = item.get(\"id\")\n            if item.get(\"acronym\"):\n                framework_acronym = item.get(\"acronym\")\n            else:\n                framework_acronym = item.get(\"name\")\n            framework_url = item.get(\"url\")\n\n            if not framework_id or not framework_acronym or not framework_url:\n                continue  # Skip this item if any critical field is empty\n\n            framework_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/frameworks/\"\n                + str(framework_id)\n            )\n\n            bundle.add((framework_URI, RDF.type, OEO.OEO_00000172))\n\n            if framework_acronym:\n                bundle.add(\n                    (\n                        framework_URI,\n                        RDFS.label,\n                        Literal(remove_non_printable(framework_acronym)),\n                    )\n                )\n\n            if framework_url:\n                bundle.add(\n                    (\n                        framework_URI,\n                        OEO[\"has_iri\"],\n                        Literal(remove_non_printable(framework_url)),\n                    )\n                )\n\n            bundle.add((study_URI, OEO[\"has_framework\"], framework_URI))\n\n        _study_keywords = (\n            json.loads(study_keywords) if study_keywords is not None else []\n        )\n        if _study_keywords != []:\n            for keyword in _study_keywords:\n                bundle.add((study_URI, OEO[\"has_study_keyword\"], Literal(keyword)))\n\n        for s, p, o in bundle.triples((None, None, None)):\n            oekg.add((s, p, o))\n\n        response = JsonResponse(\n            \"Factsheet saved\", safe=False, content_type=\"application/json\"\n        )\n        result = set_ownership(bundle_uid=uid, user=request.user)\n        logging.info(result)\n        patch_response_headers(response, cache_timeout=1)\n\n        return response\n</code></pre> <p><code>def update_factsheet(request, *args, **kwargs):</code></p> <p>Updates a scenario bundle based on user's data.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>uid</code> <code>str</code> <p>The unique ID for the bundle.</p> required <code>acronym</code> <code>str</code> <p>The acronym for the bundle.</p> required <code>abstract</code> <code>str</code> <p>The abstract for the bundle.</p> required <code>institution</code> <code>list of objects</code> <p>The institutions for the bundle.</p> required <code>funding_source</code> <code>list of objects</code> <p>The funding sources for the bundle.</p> required <code>contact_person</code> <code>list of objects</code> <p>The contact persons for the bundle.</p> required <code>sector_divisions</code> <code>list of objects</code> <p>The sector divisions for the bundle.</p> required <code>sectors</code> <code>list of objects</code> <p>The sectors for the bundle.</p> required <code>technologies</code> <code>list of objects</code> <p>The technologies for the bundle.</p> required <code>study_keywords</code> <code>list of strings</code> <p>The study keywords for the bundle.</p> required <code>scenarios</code> <code>list of objects</code> <p>The scenarios for the bundle.</p> required <code>models</code> <code>list of strings</code> <p>The models for the bundle.</p> required <code>frameworks</code> <code>list of strings</code> <p>The frameworks for the bundle.</p> required <code>publications</code> <code>list[object]</code> <p>A list of n publications related to the bundle study_name (str): The study name for the bundle. date_of_publication (str): The date of publication for the bundle. report_title (str): The report title for the bundle. report_doi (str): The report_doi for the bundle. place_of_publication (str): The place of publication for the bundle. link_to_study_report (str): The link to study for the bundle. authors (list of objects): The authors for the bundle.</p> required Source code in <code>factsheet/views.py</code> <pre><code>@login_required\n@only_if_user_is_owner_of_scenario_bundle\ndef update_factsheet(request, *args, **kwargs):\n    \"\"\"\n    Updates a scenario bundle based on user's data.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        uid (str): The unique ID for the bundle.\n        acronym (str): The acronym for the bundle.\n        abstract (str): The abstract for the bundle.\n        institution (list of objects): The institutions for the bundle.\n        funding_source (list of objects): The funding sources for the bundle.\n        contact_person (list of objects): The contact persons for the bundle.\n        sector_divisions (list of objects): The sector divisions for the bundle.\n        sectors (list of objects): The sectors for the bundle.\n        technologies (list of objects): The technologies for the bundle.\n        study_keywords (list of strings): The study keywords for the bundle.\n        scenarios (list of objects): The scenarios for the bundle.\n        models (list of strings): The models for the bundle.\n        frameworks (list of strings): The frameworks for the bundle.\n        publications (list[object]): A list of n publications related to the bundle\n            study_name (str): The study name for the bundle.\n            date_of_publication (str): The date of publication for the bundle.\n            report_title (str): The report title for the bundle.\n            report_doi (str): The report_doi for the bundle.\n            place_of_publication (str): The place of publication for the bundle.\n            link_to_study_report (str): The link to study for the bundle.\n            authors (list of objects): The authors for the bundle.\n    \"\"\"\n    request_body = json.loads(request.body)\n    fsData = request_body[\"fsData\"]\n    id = request_body[\"id\"]  # noqa\n    uid = request_body[\"uid\"]\n    name = request_body[\"name\"]  # noqa\n    studyName = request_body[\"study_name\"]\n    acronym = request_body[\"acronym\"]\n    abstract = request_body[\"abstract\"]\n    institution = request_body[\"institution\"]\n    funding_source = request_body[\"funding_source\"]\n    contact_person = request_body[\"contact_person\"]\n    sector_divisions = request_body[\"sector_divisions\"]\n    sectors = request_body[\"sectors\"]\n    expanded_sectors = request_body[\"expanded_sectors\"]  # noqa\n    # energy_carriers = request_body['energy_carriers']\n    # expanded_energy_carriers = request_body['expanded_energy_carriers']\n    # energy_transformation_processes = request_body['energy_transformation_processes']\n    # expanded_energy_transformation_processes = request_body['expanded_energy_transformation_processes'] # noqa\n    technologies = request_body[\"technologies\"]\n    study_keywords = request_body[\"study_keywords\"]\n    scenarios = request_body[\"scenarios\"]\n    models = request_body[\"models\"]\n    frameworks = request_body[\"frameworks\"]\n    publications = request_body[\"publications\"]\n\n    Duplicate_study_factsheet = False\n\n    for s, p, o in oekg.triples((None, RDF.type, OEO.OEO_00010252)):\n        study_acronym = oekg.value(s, DC.acronym)\n        if str(clean_name(acronym)) == str(study_acronym) and str(\n            clean_name(acronym)\n        ) != str(fsData[\"acronym\"]):\n            Duplicate_study_factsheet = True\n\n    if Duplicate_study_factsheet == True:  # noqa\n        response = JsonResponse(\n            \"Factsheet exists\", safe=False, content_type=\"application/json\"\n        )\n        patch_response_headers(response, cache_timeout=1)\n        return response\n\n    if Duplicate_study_factsheet == False:  # noqa\n        study_URI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + uid)\n\n        old_bundle = Graph()\n        for s, p, o in oekg.triples((study_URI, None, None)):\n            old_bundle.add((s, p, o))\n        for s, p, o in oekg.triples((study_URI, OEKG[\"has_scenario\"], None)):\n            for s1, p1, o1 in oekg.triples((o, None, None)):\n                old_bundle.add((s1, p1, o1))\n\n        new_bundle = Graph()\n        new_bundle.add((study_URI, RDF.type, OEO.OEO_00010252))\n\n        _publications = json.loads(publications) if publications is not None else []\n        for item in _publications:\n            publications_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/publication/\" + item[\"id\"]\n            )\n            new_bundle.add(\n                (publications_URI, OEKG[\"publication_uuid\"], Literal(remove_non_printable(item[\"id\"])))\n            )\n            new_bundle.add((study_URI, OEKG[\"has_publication\"], publications_URI))\n            if item[\"report_title\"] != \"\":\n                new_bundle.add(\n                    (publications_URI, RDFS.label, Literal(remove_non_printable(item[\"report_title\"])))\n                )\n\n            _authors = item[\"authors\"]\n            # Check if list is empty to avoid adding empty elements to the OEKG\n            if _authors:\n                for author in _authors:\n                    # TODO: (@adel please check):\n                    # Workaround below to avoid adding empty new\n                    # autors every time a new publication is added\n                    if author[\"name\"]:\n                        author_URI = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/\"\n                            + author[\"iri\"]\n                        )\n                        new_bundle.add((publications_URI, OEO.OEO_00000506, author_URI))\n\n            if item[\"doi\"] != \"\":\n                new_bundle.add((publications_URI, OEKG[\"doi\"], Literal(remove_non_printable(item[\"doi\"]))))\n\n            if (\n                item[\"date_of_publication\"] != \"1900\"\n                and item[\"date_of_publication\"] != \"\"\n            ):\n                new_bundle.add(\n                    (\n                        publications_URI,\n                        OEKG[\"date_of_publication\"],\n                        Literal(remove_non_printable(item[\"date_of_publication\"])),\n                    )\n                )\n\n            if item[\"link_to_study_report\"] != \"\":\n                new_bundle.add(\n                    (\n                        publications_URI,\n                        OEKG[\"link_to_study_report\"],\n                        Literal(remove_non_printable(item[\"link_to_study_report\"])),\n                    )\n                )\n\n            new_bundle.add((study_URI, OEKG[\"has_publication\"], publications_URI))\n\n            # remove old date in publication\n            # iterate to make sure it can only have unique publication date\n            for _s, _p, _o in oekg.triples(\n                (publications_URI, OEKG[\"date_of_publication\"], None)\n            ):\n                oekg.remove((_s, _p, _o))\n\n        _scenarios = json.loads(scenarios) if scenarios is not None else []\n        for item in _scenarios:\n            if item[\"acronym\"] != \"\":\n                scenario_URI = URIRef(\n                    \"http://openenergy-platform.org/ontology/oekg/scenario/\"\n                    + item[\"id\"]\n                )\n\n                for s, p, o in oekg.triples((scenario_URI, None, None)):\n                    oekg.remove((o, p, o))\n\n                new_bundle.add(\n                    (scenario_URI, OEKG[\"scenario_uuid\"], Literal(remove_non_printable(item[\"id\"])))\n                )\n                new_bundle.add((scenario_URI, RDF.type, OEO.OEO_00000365))\n                new_bundle.add((scenario_URI, RDFS.label, Literal((item[\"acronym\"]))))\n                if item[\"name\"] != \"\":\n                    new_bundle.add(\n                        (scenario_URI, OEKG[\"has_full_name\"], Literal(remove_non_printable(item[\"name\"])))\n                    )\n                if item[\"abstract\"] != \"\" and item[\"abstract\"] != None:  # noqa\n                    new_bundle.add(\n                        (scenario_URI, DC.abstract, Literal(remove_non_printable(item[\"abstract\"])))\n                    )\n                if \"regions\" in item:\n                    for region in item[\"regions\"]:\n                        region_URI = URIRef(region[\"iri\"])\n                        scenario_region = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/region/\"\n                            + region[\"iri\"].rsplit(\"/\", 1)[1]\n                        )\n                        new_bundle.add((scenario_region, RDF.type, OEO.OEO_00020032))\n                        new_bundle.add(\n                            (scenario_region, RDFS.label, Literal(remove_non_printable(region[\"name\"])))\n                        )\n                        new_bundle.add(\n                            (\n                                scenario_region,\n                                OEKG[\"reference\"],\n                                region_URI,\n                            )\n                        )\n                        new_bundle.add(\n                            (scenario_URI, OEO.OEO_00020220, scenario_region)\n                        )\n\n                if \"interacting_regions\" in item:\n                    for interacting_region in item[\"interacting_regions\"]:\n                        interacting_region_URI = URIRef(interacting_region[\"iri\"])\n                        scenario_interacting_region = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/\"\n                            + interacting_region[\"iri\"]\n                        )\n\n                        new_bundle.add(\n                            (scenario_interacting_region, RDF.type, OEO.OEO_00020036)\n                        )\n                        new_bundle.add(\n                            (\n                                scenario_interacting_region,\n                                RDFS.label,\n                                Literal(remove_non_printable(interacting_region[\"name\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                scenario_interacting_region,\n                                OEKG[\"reference\"],\n                                interacting_region_URI,\n                            )\n                        )\n\n                        new_bundle.add(\n                            (\n                                scenario_URI,\n                                OEO.OEO_00020222,\n                                scenario_interacting_region,\n                            )\n                        )\n\n                if \"scenario_years\" in item:\n                    for scenario_year in item[\"scenario_years\"]:\n                        new_bundle.add(\n                            (\n                                scenario_URI,\n                                OEO.OEO_00020224,\n                                Literal(remove_non_printable(scenario_year[\"name\"])),\n                            )\n                        )\n\n                if \"descriptors\" in item:\n                    for descriptor in item[\"descriptors\"]:\n                        descriptor = URIRef(descriptor[\"class\"])\n                        new_bundle.add(\n                            (scenario_URI, OEO[\"has_scenario_descriptor\"], descriptor)\n                        )\n\n                # TODO: jh-RLI: Update to avoid duplicated table name entries\n                if \"input_datasets\" in item:\n                    for input_dataset in item[\"input_datasets\"]:\n                        input_dataset_URI = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/input_datasets/\"  # noqa\n                            + input_dataset[\"key\"]\n                        )\n\n                        for s, p, o in oekg.triples((input_dataset_URI, None, None)):\n                            oekg.remove((o, p, o))\n\n                        new_bundle.add((input_dataset_URI, RDF.type, OEO.OEO_00030030))\n                        new_bundle.add(\n                            (\n                                input_dataset_URI,\n                                RDFS.label,\n                                Literal(remove_non_printable(input_dataset[\"value\"][\"label\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_iri\"],\n                                Literal(remove_non_printable(input_dataset[\"value\"][\"url\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_id\"],\n                                Literal(remove_non_printable(input_dataset[\"idx\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                input_dataset_URI,\n                                OEO[\"has_key\"],\n                                Literal(remove_non_printable(input_dataset[\"key\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (scenario_URI, OEO.RO_0002233, input_dataset_URI)\n                        )\n\n                # TODO: jh-RLI: Update to avoid duplicated table name entries\n                if \"output_datasets\" in item:\n                    for output_dataset in item[\"output_datasets\"]:\n                        output_dataset_URI = URIRef(\n                            \"http://openenergy-platform.org/ontology/oekg/output_datasets/\"  # noqa: E501\n                            + output_dataset[\"key\"]\n                        )\n                        new_bundle.add((output_dataset_URI, RDF.type, OEO.OEO_00030029))\n                        new_bundle.add(\n                            (\n                                output_dataset_URI,\n                                RDFS.label,\n                                Literal(remove_non_printable(output_dataset[\"value\"][\"label\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_iri\"],\n                                Literal(remove_non_printable(output_dataset[\"value\"][\"url\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_id\"],\n                                Literal(remove_non_printable(output_dataset[\"idx\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (\n                                output_dataset_URI,\n                                OEO[\"has_key\"],\n                                Literal(remove_non_printable(output_dataset[\"key\"])),\n                            )\n                        )\n                        new_bundle.add(\n                            (scenario_URI, OEO.RO_0002234, output_dataset_URI)\n                        )\n\n                new_bundle.add((study_URI, OEKG[\"has_scenario\"], scenario_URI))\n\n        if acronym != \"\":\n            new_bundle.add((study_URI, DC.acronym, Literal(remove_non_printable(acronym))))\n\n        new_bundle.add((study_URI, OEKG[\"has_full_name\"], Literal(remove_non_printable(studyName))))\n\n        institutions = json.loads(institution) if institution is not None else []\n        for item in institutions:\n            institution_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            new_bundle.add((study_URI, OEO.OEO_00000510, institution_URI))\n\n        funding_sources = (\n            json.loads(funding_source) if funding_source is not None else []\n        )\n        for item in funding_sources:\n            funding_source_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            new_bundle.add((study_URI, OEO.OEO_00000509, funding_source_URI))\n\n        if abstract != \"\":\n            new_bundle.add((study_URI, DC.abstract, Literal(remove_non_printable(abstract))))\n\n        contact_persons = (\n            json.loads(contact_person) if contact_person is not None else []\n        )\n        for item in contact_persons:\n            contact_person_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/\" + item[\"iri\"]\n            )\n            new_bundle.add((study_URI, OEO.OEO_00000508, contact_person_URI))\n\n        _sector_divisions = (\n            json.loads(sector_divisions) if sector_divisions is not None else []\n        )\n        for item in _sector_divisions:\n            sector_divisions_URI = URIRef(item[\"class\"])\n            new_bundle.add(\n                (study_URI, OEO[\"based_on_sector_division\"], sector_divisions_URI)\n            )\n\n        _sectors = json.loads(sectors) if sectors is not None else []\n        for item in _sectors:\n            sector_URI = URIRef(item[\"class\"])\n            new_bundle.add((study_URI, OEO.OEO_00000505, sector_URI))\n\n        _technologies = json.loads(technologies) if technologies is not None else []\n        for item in _technologies:\n            technology_URI = URIRef(item[\"class\"])\n            new_bundle.add((study_URI, OEO.OEO_00000522, technology_URI))\n\n        _models = json.loads(models) if models is not None else []\n        for item in _models:\n            model_id = item.get(\"id\")\n\n            if item.get(\"acronym\"):\n                model_acronym = item.get(\"acronym\")\n            else:\n                model_acronym = item.get(\"name\")\n            model_url = item.get(\"url\")\n\n            if not model_id or not model_acronym or not model_url:\n                continue  # Skip this item if any critical field is empty\n\n            model_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/models/\" + str(model_id)\n            )\n            new_bundle.add((model_URI, RDF.type, OEO.OEO_00000277))\n\n            new_bundle.add(\n                (\n                    model_URI,\n                    RDFS.label,\n                    Literal(remove_non_printable(model_acronym)),\n                )\n            )\n\n            new_bundle.add(\n                (\n                    model_URI,\n                    OEO[\"has_iri\"],\n                    Literal(remove_non_printable(model_url)),\n                )\n            )\n\n            new_bundle.add((study_URI, OEO[\"has_model\"], model_URI))\n\n            # remove old labels\n            # iterate to make sure only current selection is available\n            for _s, _p, _o in oekg.triples((model_URI, RDFS.label, None)):\n                oekg.remove((_s, _p, _o))\n\n            # remove old iri\u00b4s\n            # iterate to make sure only current selection is available\n            for _s, _p, _o in oekg.triples((model_URI, OEO[\"has_iri,\"], None)):\n                oekg.remove((_s, _p, _o))\n\n        # TODO: Fix\n        _frameworks = json.loads(frameworks) if frameworks is not None else []\n        for item in _frameworks:\n            framework_id = item.get(\"id\")\n            if item.get(\"acronym\"):\n                framework_acronym = item.get(\"acronym\")\n            else:\n                framework_acronym = item.get(\"name\")\n            framework_url = item.get(\"url\")\n\n            if not framework_id or not framework_url:\n                continue  # Skip this item if any critical field is empty\n\n            framework_URI = URIRef(\n                \"http://openenergy-platform.org/ontology/oekg/frameworks/\"\n                + str(framework_id)\n            )\n\n            new_bundle.add((framework_URI, RDF.type, OEO.OEO_00000172))\n            if framework_acronym:\n                new_bundle.add(\n                    (\n                        framework_URI,\n                        RDFS.label,\n                        Literal(remove_non_printable(framework_acronym)),\n                    )\n                )\n            if framework_url:\n                new_bundle.add(\n                    (\n                        framework_URI,\n                        OEO[\"has_iri\"],\n                        Literal(remove_non_printable(framework_url)),\n                    )\n                )\n\n            new_bundle.add((study_URI, OEO[\"has_framework\"], framework_URI))\n\n            # remove old labels\n            # iterate to make sure only current selection is available\n            for _s, _p, _o in oekg.triples((framework_URI, RDFS.label, None)):\n                oekg.remove((_s, _p, _o))\n\n            # remove old iri\u00b4s\n            # iterate to make sure only current selection is available\n            for _s, _p, _o in oekg.triples((framework_URI, OEO[\"has_iri,\"], None)):\n                oekg.remove((_s, _p, _o))\n\n        _study_keywords = (\n            json.loads(study_keywords) if study_keywords is not None else []\n        )\n        for keyword in _study_keywords:\n            new_bundle.add((study_URI, OEO[\"has_study_keyword\"], Literal(remove_non_printable(keyword))))\n\n        iso_old_bundle = to_isomorphic(old_bundle)\n        iso_new_bundle = to_isomorphic(new_bundle)\n\n        in_both, in_first, in_second = graph_diff(iso_old_bundle, iso_new_bundle)\n\n        in_first_json = str(in_first.serialize(format=\"json-ld\"))  # noqa\n        in_second_json = str(in_second.serialize(format=\"json-ld\"))  # noqa\n\n        # remove old bundle from oekg\n        for s, p, o in oekg.triples((study_URI, OEKG[\"has_scenario\"], None)):\n            oekg.remove((o, None, None))\n        oekg.remove((study_URI, None, None))\n\n        for s, p, o in oekg.triples((study_URI, OEKG[\"has_scenario\"], None)):\n            oekg.remove((o, None, None))\n        oekg.remove((study_URI, None, None))\n\n        # add updated bundle to oekg\n        for s, p, o in new_bundle.triples((None, None, None)):\n            oekg.add((s, p, o))\n\n        OEKG_Modifications_instance = OEKG_Modifications(  # noqa\n            bundle_id=uid,\n            user=login_models.myuser.objects.filter(name=request.user).first(),\n            old_state=in_first.serialize(format=\"json-ld\"),\n            new_state=in_second.serialize(format=\"json-ld\"),\n        )\n        # OEKG_Modifications_instance.save()\n\n        response = JsonResponse(\n            \"factsheet updated!\", safe=False, content_type=\"application/json\"\n        )\n        patch_response_headers(response, cache_timeout=1)\n        return response\n</code></pre> <p><code>def factsheet_by_id(request, *args, **kwargs):</code></p> <p>Returns a scenario bundle based based on the provided ID.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>id</code> <code>str</code> <p>The unique ID for the bundle.</p> required Source code in <code>factsheet/views.py</code> <pre><code>def factsheet_by_id(request, *args, **kwargs):\n    \"\"\"\n    Returns a scenario bundle based based on the provided ID.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        id (str): The unique ID for the bundle.\n    \"\"\"\n\n    uid = request.GET.get(\"id\")\n    study_URI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + uid)\n    factsheet = {}\n\n    acronym = \"\"\n    study_name = \"\"\n    abstract = \"\"\n\n    for s, p, o in oekg.triples((study_URI, DC.acronym, None)):\n        acronym = o\n\n    for s, p, o in oekg.triples((study_URI, OEKG[\"has_full_name\"], None)):\n        study_name = o\n\n    for s, p, o in oekg.triples((study_URI, DC.abstract, None)):\n        abstract = o\n\n    factsheet[\"acronym\"] = acronym\n    factsheet[\"uid\"] = uid\n    factsheet[\"study_name\"] = study_name\n    factsheet[\"abstract\"] = abstract\n    factsheet[\"publications\"] = []\n\n    factsheet[\"funding_sources\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO.OEO_00000509, None)):\n        label = oekg.value(o, RDFS.label)\n        if label != None:  # noqa\n            factsheet[\"funding_sources\"].append(\n                {\"iri\": str(o).split(\"/\")[-1], \"id\": label, \"name\": label}\n            )\n\n    factsheet[\"institution\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO.OEO_00000510, None)):\n        label = oekg.value(o, RDFS.label)\n        if label != None:  # noqa\n            factsheet[\"institution\"].append(\n                {\"iri\": str(o).split(\"/\")[-1], \"id\": label, \"name\": label}\n            )\n\n    factsheet[\"contact_person\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO.OEO_00000508, None)):\n        label = oekg.value(o, RDFS.label)\n        if label != None:  # noqa\n            factsheet[\"contact_person\"].append(\n                {\"iri\": str(o).split(\"/\")[-1], \"id\": label, \"name\": label}\n            )\n\n    factsheet[\"sector_divisions\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO[\"based_on_sector_division\"], None)):\n        label = oeo.value(o, RDFS.label)\n        class_iri = o\n        if label != None:  # noqa\n            factsheet[\"sector_divisions\"].append(\n                {\"value\": label, \"name\": label, \"class\": class_iri}\n            )\n\n    factsheet[\"sectors\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO.OEO_00000505, None)):\n        label = oeo.value(o, RDFS.label)\n        class_iri = o\n        if label != None:  # noqa\n            factsheet[\"sectors\"].append(\n                {\"value\": label, \"label\": label, \"class\": class_iri}\n            )\n\n    # factsheet['energy_carriers'] = []\n    # for s, p, o in oekg.triples(( study_URI, OEO[\"covers_energy_carrier\"], None )):\n    #     label = oeo.value(o, RDFS.label)\n    #     class_label = oeo.value(o, RDFS.label)\n    #     if label != None:\n    #         factsheet['energy_carriers'].append({ \"value\": label, \"label\":label, \"class\": o }) # noqa: E501\n\n    # factsheet['energy_transformation_processes'] = []\n    # for s, p, o in oekg.triples(( study_URI, OEO[\"covers_transformation_processes\"], None )): # noqa: E501\n    #     label = oeo.value(o, RDFS.label)\n    #     if label != None:\n    #         factsheet['energy_transformation_processes'].append({ \"value\": label, \"label\":label, \"class\": o }) # noqa: E501\n\n    factsheet[\"technologies\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO.OEO_00000522, None)):\n        label = oeo.value(o, RDFS.label)\n        if label != None:  # noqa\n            factsheet[\"technologies\"].append(\n                {\"value\": label, \"label\": label, \"class\": o}\n            )\n\n    factsheet[\"study_keywords\"] = []\n    for s, p, o in oekg.triples((study_URI, OEO[\"has_study_keyword\"], None)):\n        if o != None:  # noqa\n            factsheet[\"study_keywords\"].append(o)\n\n    factsheet[\"models\"] = []\n    factsheet[\"frameworks\"] = []\n\n    for _, _, o in oekg.triples((study_URI, OEO[\"has_framework\"], None)):\n        for _, _, o1 in oekg.triples((o, OEO[\"has_iri\"], None)):\n            framework_id = int(str(o).split(\"/\")[-1])\n            framework_metadata = get_framework_metadata_by_id(\n                framework_id, \"energyframework\"\n            )\n\n            if framework_metadata:\n                framework_metadata[\"url\"] = str(o1)\n                factsheet[\"frameworks\"].append(framework_metadata)\n\n    for _, _, o in oekg.triples((study_URI, OEO[\"has_model\"], None)):\n        for _, _, o1 in oekg.triples((o, OEO[\"has_iri\"], None)):\n            model_id = int(str(o).split(\"/\")[-1])\n            model_metadata = get_model_metadata_by_id(model_id, \"energymodel\")\n\n            if model_metadata:\n                model_metadata[\"url\"] = str(o1)\n                factsheet[\"models\"].append(model_metadata)\n\n    temp = set()\n    factsheet[\"publications\"] = []\n    for s, p, o in oekg.triples((study_URI, OEKG[\"has_publication\"], None)):\n        publication = {}\n\n        publication[\"report_title\"] = \"\"\n        label = oekg.value(o, RDFS.label)\n        if label is not None:\n            publication[\"report_title\"] = label\n\n        publication_uuid = oekg.value(o, OEKG[\"publication_uuid\"])\n        publication[\"id\"] = publication_uuid\n\n        publication[\"authors\"] = []\n        for s1, p1, o1 in oekg.triples((o, OEO.OEO_00000506, None)):\n            o1_label = oekg.value(o1, RDFS.label)\n            publication[\"authors\"].append({\"iri\": o1, \"name\": o1_label})\n\n        publication[\"doi\"] = \"\"\n        for s2, p2, o2 in oekg.triples((o, OEKG[\"doi\"], None)):\n            publication[\"doi\"] = o2\n\n        publication[\"date_of_publication\"] = \"\"\n        for s3, p3, o3 in oekg.triples((o, OEKG[\"date_of_publication\"], None)):\n            publication[\"date_of_publication\"] = serialize_publication_date(str(o3))\n            temp.update(serialize_publication_date(str(o3)))\n\n        # Convert set to list before creating the JSON response\n        factsheet[\"collected_scenario_publication_dates\"] = list(temp)\n\n        publication[\"link_to_study_report\"] = \"\"\n        for s4, p4, o4 in oekg.triples((o, OEKG[\"link_to_study_report\"], None)):\n            publication[\"link_to_study_report\"] = o4\n\n        factsheet[\"publications\"].append(publication)\n\n    factsheet[\"scenarios\"] = []\n    for s, p, o in oekg.triples((study_URI, OEKG[\"has_scenario\"], None)):\n        scenario = {}\n        label = oekg.value(o, RDFS.label)\n        scenario_uuid = oekg.value(o, OEKG[\"scenario_uuid\"])\n\n        if label != None:  # noqa\n            scenario[\"acronym\"] = label\n\n        scenario[\"id\"] = scenario_uuid\n        scenario[\"scenario_years\"] = []\n        scenario[\"regions\"] = []\n        scenario[\"interacting_regions\"] = []\n        scenario[\"descriptors\"] = []\n        scenario[\"input_datasets\"] = []\n        scenario[\"output_datasets\"] = []\n\n        abstract = oekg.value(o, DC.abstract)\n        name = oekg.value(o, OEKG[\"has_full_name\"])\n        scenario[\"name\"] = name\n        scenario[\"abstract\"] = abstract\n\n        for s1, p1, o1 in oekg.triples((o, OEO.OEO_00020220, None)):\n            o1_type = oekg.value(o1, RDF.type)\n            o1_label = oekg.value(o1, RDFS.label)\n            scenario[\"regions\"].append({\"iri\": o1, \"name\": o1_label})\n\n        for s1, p1, o1 in oekg.triples((o, OEO.OEO_00020222, None)):\n            o1_type = oekg.value(o1, RDF.type)  # noqa\n            o1_label = oekg.value(o1, RDFS.label)\n            scenario[\"interacting_regions\"].append(\n                {\"iri\": str(o1).split(\"/\")[-1], \"id\": o1_label, \"name\": o1_label}\n            )\n\n        for s11, p11, o11 in oekg.triples((o, OEO[\"has_scenario_descriptor\"], None)):\n            label = oeo.value(o11, RDFS.label)\n            scenario[\"descriptors\"].append(\n                {\"value\": label, \"label\": label, \"class\": o11}\n            )\n\n        for s2, p2, o2 in oekg.triples((o, OEO.RO_0002233, None)):\n            o2_iri = oekg.value(o2, OEO[\"has_iri\"])\n            o2_label = oekg.value(o2, RDFS.label)\n            o2_key = oekg.value(o2, OEO[\"has_key\"])\n            o2_idx = oekg.value(o2, OEO[\"has_id\"])\n\n            scenario[\"input_datasets\"].append(\n                {\n                    \"key\": o2_key,\n                    \"idx\": o2_idx,\n                    \"value\": {\"label\": o2_label, \"url\": o2_iri},\n                }\n            )\n\n        for s3, p3, o3 in oekg.triples((o, OEO.RO_0002234, None)):\n            o3_iri = oekg.value(o3, OEO[\"has_iri\"])\n            o3_label = oekg.value(o3, RDFS.label)\n            o3_key = oekg.value(o3, OEO[\"has_key\"])\n            o3_idx = oekg.value(o3, OEO[\"has_id\"])\n\n            scenario[\"output_datasets\"].append(\n                {\n                    \"key\": o3_key,\n                    \"idx\": o3_idx,\n                    \"value\": {\"label\": o3_label, \"url\": o3_iri},\n                }\n            )\n\n        for s4, p4, o4 in oekg.triples((o, OEO.OEO_00020224, None)):\n            scenario[\"scenario_years\"].append({\"id\": o4, \"name\": o4})\n\n        factsheet[\"scenarios\"].append(scenario)\n\n    response = JsonResponse(factsheet, safe=False, content_type=\"application/json\")\n    patch_response_headers(response, cache_timeout=1)\n\n    scenario_region = URIRef(\n        \"http://openenergy-platform.org/ontology/oekg/region/Germany\"\n    )\n    for s, p, o in oekg.triples((scenario_region, RDFS.label, None)):\n        if str(o) == \"None\":\n            oekg.remove((s, p, o))\n            oekg.add((s, p, Literal(\"Germany\")))\n\n    return response\n</code></pre> <p><code>def delete_factsheet_by_id(request, *args, **kwargs):</code></p> <p>Removes a scenario bundle based on the provided ID.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>id</code> <code>str</code> <p>The unique ID for the bundle.</p> required Source code in <code>factsheet/views.py</code> <pre><code>@only_if_user_is_owner_of_scenario_bundle\n@login_required\ndef delete_factsheet_by_id(request, *args, **kwargs):\n    \"\"\"\n    Removes a scenario bundle based on the provided ID.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        id (str): The unique ID for the bundle.\n\n    \"\"\"\n    id = request.GET.get(\"id\")\n    study_URI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + id)\n\n    for s, p, o in oekg.triples((study_URI, OEKG[\"has_scenario\"], None)):\n        oekg.remove((o, None, None))\n    oekg.remove((study_URI, None, None))\n\n    response = JsonResponse(\n        \"factsheet removed!\", safe=False, content_type=\"application/json\"\n    )\n    patch_response_headers(response, cache_timeout=1)\n    return response\n</code></pre> <p><code>def add_entities(request, *args, **kwargs):</code></p> <p>Add entities to OEKG. The minimum requirements for adding an entity are the type and label.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>entity_type</code> <code>str</code> <p>The type(OEO class) of the entity.</p> required <code>entity_label</code> <code>str</code> <p>The label of the entity.</p> required <code>entity_iri</code> <code>str</code> <p>The IRI of the entity.</p> required Source code in <code>factsheet/views.py</code> <pre><code>@login_required\ndef add_entities(request, *args, **kwargs):\n    \"\"\"\n    Add entities to OEKG. The minimum requirements for\n    adding an entity are the type and label.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        entity_type (str): The type(OEO class) of the entity.\n        entity_label (str): The label of the entity.\n        entity_iri (str): The IRI of the entity.\n    \"\"\"\n    request_body = json.loads(request.body)\n    entity_type = request_body[\"entity_type\"]\n    entity_label = request_body[\"entity_label\"]\n    entity_iri = request_body[\"entity_iri\"]\n\n    vocab = entity_type.split(\".\")[0]\n    classId = entity_type.split(\".\")[1]\n    prefix = \"\"\n    if vocab == \"OEO\":\n        prefix = \"http://openenergy-platform.org/ontology/oeo/\"\n    if vocab == \"OBO\":\n        prefix = \"http://purl.obolibrary.org/obo/\"\n\n    entity_type_URI = URIRef(prefix + classId)\n\n    entity_URI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + entity_iri)\n\n    oekg.add((entity_URI, RDF.type, entity_type_URI))\n    oekg.add((entity_URI, RDFS.label, Literal(entity_label)))\n\n    response = JsonResponse(\n        \"A new entity added!\", safe=False, content_type=\"application/json\"\n    )\n    patch_response_headers(response, cache_timeout=1)\n    return response\n</code></pre> <p><code>def delete_entities(request, *args, **kwargs):</code></p> <p>Removes an entity from OEKG. The minimum requirements for removing an entity are the type and label.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>entity_type</code> <code>str</code> <p>The type(OEO class) of the entity.</p> required <code>entity_label</code> <code>str</code> <p>The label of the entity.</p> required Source code in <code>factsheet/views.py</code> <pre><code>@login_required\ndef delete_entities(request, *args, **kwargs):\n    \"\"\"\n    Removes an entity from OEKG. The minimum requirements for\n    removing an entity are the type and label.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        entity_type (str): The type(OEO class) of the entity.\n        entity_label (str): The label of the entity.\n    \"\"\"\n    entity_type = request.GET.get(\"entity_type\")\n    entity_label = request.GET.get(\"entity_label\")\n\n    entity_URI = URIRef(  # noqa\n        \"http://openenergy-platform.org/ontology/oekg/\" + entity_type\n    )\n    entity_Label = URIRef(\n        \"http://openenergy-platform.org/ontology/oekg/\" + (entity_label)\n    )\n\n    oekg.remove((entity_Label, None, None))\n    oekg.remove((None, None, entity_Label))\n    response = JsonResponse(\n        \"entity removed!\", safe=False, content_type=\"application/json\"\n    )\n    patch_response_headers(response, cache_timeout=1)\n    return response\n</code></pre> <p><code>def update_an_entity(request, *args, **kwargs):</code></p> <p>Updates an entity in OEKG. The minimum requirements for updating an entity are the type, the old label, and the new label.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>entity_type</code> <code>str</code> <p>The type(OEO class) of the entity.</p> required <code>entity_label</code> <code>str</code> <p>The label of the entity.</p> required <code>new_entity_label</code> <code>str</code> <p>The new label of the entity.</p> required <code>entity_id</code> <code>str</code> <p>The IRI of the entity.</p> required Source code in <code>factsheet/views.py</code> <pre><code>@login_required\ndef update_an_entity(request, *args, **kwargs):\n    \"\"\"\n    Updates an entity in OEKG. The minimum requirements for\n    updating an entity are the type, the old label, and the\n    new label.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        entity_type (str): The type(OEO class) of the entity.\n        entity_label (str): The label of the entity.\n        new_entity_label (str): The new label of the entity.\n        entity_id (str): The IRI of the entity.\n    \"\"\"\n    request_body = json.loads(request.body)\n    entity_type = request_body[\"entity_type\"]\n    entity_label = request_body[\"entity_label\"]\n    new_entity_label = request_body[\"new_entity_label\"]\n    entity_id = request_body[\"entity_iri\"]\n\n    vocab = entity_type.split(\".\")[0]\n    classId = entity_type.split(\".\")[1]\n    prefix = \"\"\n    if vocab == \"OEO\":\n        prefix = \"http://openenergy-platform.org/ontology/oeo/\"\n    if vocab == \"OBO\":\n        prefix = \"http://purl.obolibrary.org/obo/\"\n\n    entity_type_URI = URIRef(prefix + classId)  # noqa\n    entity_IRI = URIRef(\"http://openenergy-platform.org/ontology/oekg/\" + (entity_id))\n\n    oekg.add((entity_IRI, RDFS.label, Literal(new_entity_label)))\n    oekg.remove((entity_IRI, RDFS.label, Literal(entity_label)))\n\n    response = JsonResponse(\n        \"entity updated!\", safe=False, content_type=\"application/json\"\n    )\n    patch_response_headers(response, cache_timeout=1)\n    return response\n</code></pre> <p><code>def query_oekg(request, *args, **kwargs):</code></p> <p>This function takes filter objects provided by the user and utilises them to construct a SPARQL query.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>criteria</code> <code>str</code> <p>An object that contains institutions, authors,</p> required Source code in <code>factsheet/views.py</code> <pre><code>@login_required\ndef query_oekg(request, *args, **kwargs):\n    \"\"\"\n    This function takes filter objects provided by the user and utilises\n    them to construct a SPARQL query.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        criteria (str): An object that contains institutions, authors,\n        funding sources, start date of the publications, end date of publications\n        study descriptors, and a range for scenario years. All of these fields\n        are utilised to construct a SPARQL query for execution on the OEKG.\n\n    \"\"\"\n    request_body = json.loads(request.body)\n    criteria = request_body[\"criteria\"]\n\n    institutes_list = criteria[\"institutions\"]\n    authors_list = criteria[\"authors\"]\n    funding_sources_list = criteria[\"fundingSource\"]\n    publication_date_start_value = criteria[\"startDateOfPublication\"]\n    publication_date_end_value = criteria[\"endDateOfPublication\"]\n    study_keywords_list = criteria[\"studyKewords\"]\n    scenario_year_start_value = criteria[\"scenarioYearValue\"][0]\n    scenario_year_end_value = criteria[\"scenarioYearValue\"][1]\n\n    query_structure = \"\"\"\n        PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n        PREFIX RDFS: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\n        PREFIX OEO: &lt;http://openenergy-platform.org/ontology/oeo/&gt;\n        PREFIX OEKG: &lt;http://openenergy-platform.org/ontology/oekg/&gt;\n        PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\n        PREFIX DC: &lt;http://purl.org/dc/terms/&gt;\n\n        SELECT DISTINCT ?study_acronym\n        WHERE\n        SELECT DISTINCT ?study_acronym\n        WHERE\n        {{\n        ?s OEO:OEO_00000510 ?institutes ;\n            {authors_exp}\n            {funding_source_exp}\n            OEKG:date_of_publication ?publication_date ;\n            OEO:has_study_keyword ?study_keywords ;;\n            DC:acronym ?study_acronym .\n\n        FILTER ((?institutes IN ({institutes}) )\n        || (?authors IN ({authors}) )\n        || (?funding_sources IN ({funding_sources}) )\n        || (?publication_date &gt;= \"{publication_date_start}\"^^xsd:date &amp;&amp; ?publication_date &lt;= \"{publication_date_end}\"^^xsd:date)\n        || (?study_keywords IN ({study_keywords}) ) )\n\n        }}\"\"\"  # noqa: E501\n\n    final_query = query_structure.format(\n        institutes=str(institutes_list)\n        .replace(\"[\", \"\")\n        .replace(\"]\", \"\")\n        .replace(\"'\", \"\"),\n        authors=str(authors_list).replace(\"[\", \"\").replace(\"]\", \"\").replace(\"'\", \"\"),\n        funding_sources=str(funding_sources_list)\n        .replace(\"[\", \"\")\n        .replace(\"]\", \"\")\n        .replace(\"'\", \"\"),\n        publication_date_start=publication_date_start_value,\n        publication_date_end=publication_date_end_value,\n        study_keywords=str(study_keywords_list).replace(\"[\", \"\").replace(\"]\", \"\"),\n        scenario_year_start=scenario_year_start_value,\n        scenario_year_end=scenario_year_end_value,\n        funding_source_exp=(\n            \"OEO:OEO_00000509 ?funding_sources ;\" if funding_sources_list != [] else \"\"\n        ),\n        authors_exp=\"OEO:OEO_00000506 ?authors ;\" if authors_list != [] else \"\",\n    )\n\n    sparql.setReturnFormat(JSON)\n    sparql.setQuery(final_query)\n    results = sparql.query().convert()\n\n    response = JsonResponse(\n        results[\"results\"][\"bindings\"],\n        safe=False,\n        content_type=\"application/json\",\n    )\n    return response\n</code></pre> <p><code>def get_entities_by_type(request, *args, **kwargs):</code></p> <p>Returns all entities (from OEKG) with a certain type. The type should be supplied by the user.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>The incoming HTTP GET request.</p> required <code>entity_type</code> <code>str</code> <p>The type(OEO class) of the entity.</p> required Source code in <code>factsheet/views.py</code> <pre><code>def get_entities_by_type(request, *args, **kwargs):\n    \"\"\"\n    Returns all entities (from OEKG) with a certain type.\n    The type should be supplied by the user.\n\n    Args:\n        request (HttpRequest): The incoming HTTP GET request.\n        entity_type (str): The type(OEO class) of the entity.\n    \"\"\"\n    entity_type = request.GET.get(\"entity_type\")\n    vocab = entity_type.split(\".\")[0]\n    classId = entity_type.split(\".\")[1]\n    prefix = \"\"\n    if vocab == \"OEO\":\n        prefix = \"http://openenergy-platform.org/ontology/oeo/\"\n    if vocab == \"OBO\":\n        prefix = \"http://purl.obolibrary.org/obo/\"\n\n    entity_URI = URIRef(prefix + classId)\n\n    entities = []\n    for s, p, o in oekg.triples((None, RDF.type, entity_URI)):\n        sl = oekg.value(s, RDFS.label)\n        entities.append({\"name\": sl, \"id\": sl, \"iri\": str(s).split(\"/\")[-1]})\n\n    response = JsonResponse(entities, safe=False, content_type=\"application/json\")\n    patch_response_headers(response, cache_timeout=1)\n    return response\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/web-api/","title":"Web API\u00b4s","text":"<p>This section describes the web APIs provided by the oeplatform. In the context of the oeplatform, the web APIs include http request interfaces that require an expected request body with a JSON data structure to formulate the specific request. As a result, a JSON response is sent back.</p> <p>Currently, a REST API is used that provides basic data management functions for interacting with the OEDB, with a focus on interacting with the data uploaded by users. The other WEB API provides functions for interacting with the scenario bundles. With this API, users can perform complex semantic queries.</p>"},{"location":"install-and-documentation/oeplatform-code/web-api/oedb-rest-api/","title":"Rest (http) API","text":"<p>We are still in the process of migrating this document!</p> <p>If you are looking for our former ReadTheDocs based documentation: We do not support it anymore and added a redirect to this page here. Migrating the outdated documentation and updating the content will take some time. Please revisit this page later again.</p> <p>In the meantime we suggest you to have a look at our Courses &amp; Tutorials available in the Academy.</p>"},{"location":"install-and-documentation/oeplatform-code/web-api/oedb-rest-api/#what-the-rest-api-offers","title":"What the Rest-API offers","text":"<p>When working with data, it is very helpful to be able to implement programmatic solutions for managing data resources. The Rest API provides such functionality by opening the underlying database of the OEP website via HTTP. Users can access data tables under specific IRI's and retrieve various information artefacts. Following the REST specification, the common JSON format is used to transfer the data. External applications can easily process such JSON data and also upload new data to the database. This document provides information on the so called API Endpoint specification. This Information is relevant to use the CRUD functionality of the REST-API.</p>"},{"location":"install-and-documentation/oeplatform-code/web-api/oedb-rest-api/#open-api","title":"Open API","text":"<p>Below you see a draft version of the OpenAPI-based. It is the documentation for all HTTP-API endpoints and in the future it can be used to test out the API.</p> API Documentation"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/","title":"Index","text":""},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#django-view-for-the-scenario-bundles","title":"Django view for the scenario bundles","text":"<p>Note</p> <p>Some of the information on this page may be changed in the future. To review the most recent information, please revisit.</p>"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#create-a-new-bundle-in-oekg","title":"Create a new bundle in OEKG","text":"<p><code>https://openenergy-platform.org/scenario-bundles/add/</code></p> <p>An example of input parameters</p> <pre><code>{\n  \"id\": \"new\",\n  \"uid\": \"6157d6d6-7a7b-a61e-21d3-a8f936b19056\",\n  \"study_name\": \"Example study name\",\n  \"acronym\": \"Example acronym\",\n  \"abstract\": \"Example abstract ...\",\n  \"institution\": [\n    {\n      \"iri\": \"708ad5dc-7f8b-6c65-6a5f-0fc54fe8221b\",\n      \"name\": \"\u00d6ko-Institut e.V.\"\n    },\n    {\n      \"iri\": \"8e1515b9-9b1f-fa06-a3a2-d552b0ea7dcd\",\n      \"name\": \"Otto-von-Guericke-Universit\u00e4t Magdeburg\"\n    }\n  ],\n  \"funding_source\": [\n    {\n      \"iri\": \"82dd628d-f748-560b-b0cd-06466cf90f1a\",\n      \"name\": \"Bundesministerium f\u00fcr Umwelt, Naturschutz und nukleare Sicherheit\"\n    }\n  ],\n  \"contact_person\": [],\n  \"sector_divisions\": [],\n  \"sectors\": [\n    {\n      \"label\": \"KSG sector buildings\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010067\"\n    },\n    {\n      \"label\": \"KSG sector industry\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010066\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): wetlands\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010192\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): other product manufacture and use\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010172\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): manure management\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010180\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): multilateral operations\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010203\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): chemical industry - other\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010353\"\n    }\n  ],\n  \"technologies\": [\n    {\n      \"label\": \"power generation technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010423\"\n    },\n    {\n      \"label\": \"wind power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010424\"\n    },\n    {\n      \"label\": \"offshore wind power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010426\"\n    },\n    {\n      \"label\": \"solar thermal power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010429\"\n    },\n    {\n      \"label\": \"hydro power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010431\"\n    },\n    {\n      \"label\": \"run of river power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010432\"\n    }\n  ],\n  \"study_descriptors\": [\n    \"life cycle analysis\",\n    \"(changes in) demand\",\n    \"degree of electrifiaction\",\n    \"Reallabor\",\n    \"regionalisation\",\n    \"peak electricity generation\"\n  ],\n  \"report_title\": \"Example report title\",\n  \"date_of_publication\": \" 2021\",\n  \"report_doi\": \"5345-43-5634-6-346-46-43\",\n  \"place_of_publication\": \"\",\n  \"link_to_study\": \" https://openenergy-platform.org/\",\n  \"authors\": [],\n  \"scenarios\": [\n    {\n      \"id\": \"4974db65-542d-31cd-6f08-11ef9a58680a\",\n      \"name\": \"Example scenario name 1 \",\n      \"acronym\": \"Example scenario acronym 1 \",\n      \"abstract\": \"Example scenario abstract 1 ... \",\n      \"regions\": [\n        {\n          \"name \": \"Germany  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Germany \"\n        }\n      ],\n      \"interacting_regions\": [\n        {\n          \"name \": \"Spain  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Spain \"\n        }\n      ],\n      \"scenario_years\": [\n        {\n          \"iri \": \"33131404-e58e-12bc-170e-32aba1c83d99 \",\n          \"name \": \"2021 \"\n        }\n      ],\n      \"descriptors \": [\n        {\n          \"label\": \"explorative scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00020248 \"\n        },\n        {\n          \"label\": \"policy scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00020309 \"\n        },\n        {\n          \"label\": \"climate scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00030007\"\n        }\n      ],\n      \"input_datasets\": [\n        {\n          \"key\": \"f2d32e9c-1fa0-4d66-9ffd-c297d4bb5c9a \",\n          \"idx\": 0,\n          \"value \": {\n            \"label \": \"abbb_transmission_capacity \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transmission_capacity \"\n          }\n        },\n        {\n          \"key \": \"ca9c82f3-9ba0-7d71-6601-dd520680bedb \",\n          \"idx \": 1,\n          \"value \": {\n            \"label \": \"abbb_demand \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_demand \"\n          }\n        }\n      ],\n      \"output_datasets \": [\n        {\n          \"key \": \"0db015dd-1543-f0e9-9579-3602fb16a680 \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"abbb_transformer \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transformer \"\n          }\n        }\n      ]\n    },\n    {\n      \"id \": \"1f4bb594-4b1c-dca4-2465-e04a54eec10b \",\n      \"name \": \"Example scenario name 2 \",\n      \"acronym \": \"Example scenario acronym 2 \",\n      \"abstract \": \"Example scenario abstract 2 ... \",\n      \"regions \": [\n        {\n          \"name \": \"France  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/France \"\n        }\n      ],\n      \"interacting_regions \": [\n        {\n          \"name \": \"Germany  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Germany \"\n        }\n      ],\n      \"scenario_years \": [],\n      \"descriptors \": [\n        {\n          \"label \": \"explorative scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020248 \"\n        },\n        {\n          \"label \": \"with additional measures scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020312 \"\n        },\n        {\n          \"label \": \"greenhouse gas emission scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020317 \"\n        },\n        {\n          \"label \": \"climate scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00030007 \"\n        },\n        {\n          \"label \": \"economic scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00030008 \"\n        }\n      ],\n      \"input_datasets \": [\n        {\n          \"key \": \"bfc811ee-11f5-6a5a-247d-6f66bb676dd9 \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"abbb_transformer \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transformer \"\n          }\n        }\n      ],\n      \"output_datasets \": [\n        {\n          \"key \": \"fbc30f51-7f32-9c21-dfb2-7534aeac538d \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"ego_slp_parameters \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/ego_slp_parameters \"\n          }\n        }\n      ]\n    }\n  ],\n  \"models\": [\n    {\n      \"id \": \"SciGrid: Open Source Reference Model of European Transmission Networks for Scientific Analysis \",\n      \"name \": \"SciGrid: Open Source Reference Model of European Transmission Networks for Scientific Analysis \"\n    },\n    {\n      \"id \": \"Balmorel \",\n      \"name \": \"Balmorel \"\n    },\n    {\n      \"id \": \"National Electricity Market Optimiser \",\n      \"name \": \"National Electricity Market Optimiser \"\n    },\n    {\n      \"id \": \"urbs Bavaria \",\n      \"name \": \"urbs Bavaria \"\n    }\n  ],\n  \"frameworks\": [\n    {\n      \"id \": \"Python for Power System Analysis toolbox (PyPSA) \",\n      \"name \": \"Python for Power System Analysis toolbox (PyPSA) \"\n    },\n    {\n      \"id \": \"Framework for Integrated Energy System Assessment \",\n      \"name \": \"Framework for Integrated Energy System Assessment \"\n    },\n    {\n      \"id \": \"Model Order Reduction for Gas and Energy Networks \",\n      \"name \": \"Model Order Reduction for Gas and Energy Networks \"\n    },\n    {\n      \"id \": \"OMEGAlpes \",\n      \"name \": \"OMEGAlpes \"\n    },\n    {\n      \"id \": \"Potsdam Integrated Assessment Modeling Framework (PIAM) \",\n      \"name \": \"Potsdam Integrated Assessment Modeling Framework (PIAM) \"\n    }\n  ]\n}\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#get-a-bundle-in-oekg","title":"Get a bundle in OEKG","text":"<p>Retrieve a bundle by its <code>uid</code></p> <p><code>https://openenergy-platform.org/scenario-bundles/get/</code></p> <p>An example of input parameters</p> <pre><code>\"uid\" : \"6157d6d6-7a7b-a61e-21d3-a8f936b19056\",\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#remove-a-bundle-from-oekg","title":"Remove a bundle from OEKG","text":"<p><code>https://openenergy-platform.org/scenario-bundles/delete/</code></p> <p>To delete a bundle, the <code>uid</code> of the bundle should be provided.</p> <p>An example of input parameters</p> <pre><code>\"uid\" : \"6157d6d6-7a7b-a61e-21d3-a8f936b19056\",\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#update-a-bundle-in-oekg","title":"Update a bundle in OEKG","text":"<p><code>https://openenergy-platform.org/scenario-bundles/update/</code></p> <p>An example of input parameters</p> <p>The <code>uid</code> should belong to an existing bundle in OEKG. The remaining fields are identical to those in the create bundle API.</p> <pre><code>{\n  \"uid\": \"6157d6d6-7a7b-a61e-21d3-a8f936b19056\",\n  \"study_name\": \"Example study name\",\n  \"acronym\": \"Example acronym\",\n  \"abstract\": \"Example abstract ...\",\n  \"institution\": [\n    {\n      \"iri\": \"708ad5dc-7f8b-6c65-6a5f-0fc54fe8221b\",\n      \"name\": \"\u00d6ko-Institut e.V.\"\n    },\n    {\n      \"iri\": \"8e1515b9-9b1f-fa06-a3a2-d552b0ea7dcd\",\n      \"name\": \"Otto-von-Guericke-Universit\u00e4t Magdeburg\"\n    }\n  ],\n  \"funding_source\": [\n    {\n      \"iri\": \"82dd628d-f748-560b-b0cd-06466cf90f1a\",\n      \"name\": \"Bundesministerium f\u00fcr Umwelt, Naturschutz und nukleare Sicherheit\"\n    }\n  ],\n  \"contact_person\": [],\n  \"sector_divisions\": [],\n  \"sectors\": [\n    {\n      \"label\": \"KSG sector buildings\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010067\"\n    },\n    {\n      \"label\": \"KSG sector industry\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010066\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): wetlands\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010192\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): other product manufacture and use\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010172\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): manure management\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010180\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): multilateral operations\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010203\"\n    },\n    {\n      \"label\": \"CRF sector (IPCC 2006): chemical industry - other\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010353\"\n    }\n  ],\n  \"technologies\": [\n    {\n      \"label\": \"power generation technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010423\"\n    },\n    {\n      \"label\": \"wind power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010424\"\n    },\n    {\n      \"label\": \"offshore wind power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010426\"\n    },\n    {\n      \"label\": \"solar thermal power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010429\"\n    },\n    {\n      \"label\": \"hydro power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010431\"\n    },\n    {\n      \"label\": \"run of river power technology\",\n      \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00010432\"\n    }\n  ],\n  \"study_descriptors\": [\n    \"life cycle analysis\",\n    \"(changes in) demand\",\n    \"degree of electrifiaction\",\n    \"Reallabor\",\n    \"regionalisation\",\n    \"peak electricity generation\"\n  ],\n  \"report_title\": \"Example report title\",\n  \"date_of_publication\": \" 2021\",\n  \"report_doi\": \"5345-43-5634-6-346-46-43\",\n  \"place_of_publication\": \"\",\n  \"link_to_study\": \" https://openenergy-platform.org/\",\n  \"authors\": [],\n  \"scenarios\": [\n    {\n      \"id\": \"4974db65-542d-31cd-6f08-11ef9a58680a\",\n      \"name\": \"Example scenario name 1 \",\n      \"acronym\": \"Example scenario acronym 1 \",\n      \"abstract\": \"Example scenario abstract 1 ... \",\n      \"regions\": [\n        {\n          \"name \": \"Germany  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Germany \"\n        }\n      ],\n      \"interacting_regions\": [\n        {\n          \"name \": \"Spain  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Spain \"\n        }\n      ],\n      \"scenario_years\": [\n        {\n          \"iri \": \"33131404-e58e-12bc-170e-32aba1c83d99 \",\n          \"name \": \"2021 \"\n        }\n      ],\n      \"descriptors \": [\n        {\n          \"label\": \"explorative scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00020248 \"\n        },\n        {\n          \"label\": \"policy scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00020309 \"\n        },\n        {\n          \"label\": \"climate scenario \",\n          \"class\": \"http://openenergy-platform.org/ontology/oeo/OEO_00030007\"\n        }\n      ],\n      \"input_datasets\": [\n        {\n          \"key\": \"f2d32e9c-1fa0-4d66-9ffd-c297d4bb5c9a \",\n          \"idx\": 0,\n          \"value \": {\n            \"label \": \"abbb_transmission_capacity \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transmission_capacity \"\n          }\n        },\n        {\n          \"key \": \"ca9c82f3-9ba0-7d71-6601-dd520680bedb \",\n          \"idx \": 1,\n          \"value \": {\n            \"label \": \"abbb_demand \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_demand \"\n          }\n        }\n      ],\n      \"output_datasets \": [\n        {\n          \"key \": \"0db015dd-1543-f0e9-9579-3602fb16a680 \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"abbb_transformer \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transformer \"\n          }\n        }\n      ]\n    },\n    {\n      \"id \": \"1f4bb594-4b1c-dca4-2465-e04a54eec10b \",\n      \"name \": \"Example scenario name 2 \",\n      \"acronym \": \"Example scenario acronym 2 \",\n      \"abstract \": \"Example scenario abstract 2 ... \",\n      \"regions \": [\n        {\n          \"name \": \"France  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/France \"\n        }\n      ],\n      \"interacting_regions \": [\n        {\n          \"name \": \"Germany  \",\n          \"iri \": \"https://www.omg.org/spec/LCC/Countries/ISO3166-1-CountryCodes/Germany \"\n        }\n      ],\n      \"scenario_years \": [],\n      \"descriptors \": [\n        {\n          \"label \": \"explorative scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020248 \"\n        },\n        {\n          \"label \": \"with additional measures scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020312 \"\n        },\n        {\n          \"label \": \"greenhouse gas emission scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00020317 \"\n        },\n        {\n          \"label \": \"climate scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00030007 \"\n        },\n        {\n          \"label \": \"economic scenario \",\n          \"class \": \"http://openenergy-platform.org/ontology/oeo/OEO_00030008 \"\n        }\n      ],\n      \"input_datasets \": [\n        {\n          \"key \": \"bfc811ee-11f5-6a5a-247d-6f66bb676dd9 \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"abbb_transformer \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/abbb_transformer \"\n          }\n        }\n      ],\n      \"output_datasets \": [\n        {\n          \"key \": \"fbc30f51-7f32-9c21-dfb2-7534aeac538d \",\n          \"idx \": 0,\n          \"value \": {\n            \"label \": \"ego_slp_parameters \",\n            \"iri \": \"https://openenergy-platform.org/dataedit/view/scenario/ego_slp_parameters \"\n          }\n        }\n      ]\n    }\n  ],\n  \"models\": [\n    {\n      \"id \": \"SciGrid: Open Source Reference Model of European Transmission Networks for Scientific Analysis \",\n      \"name \": \"SciGrid: Open Source Reference Model of European Transmission Networks for Scientific Analysis \"\n    },\n    {\n      \"id \": \"Balmorel \",\n      \"name \": \"Balmorel \"\n    },\n    {\n      \"id \": \"National Electricity Market Optimiser \",\n      \"name \": \"National Electricity Market Optimiser \"\n    },\n    {\n      \"id \": \"urbs Bavaria \",\n      \"name \": \"urbs Bavaria \"\n    }\n  ],\n  \"frameworks\": [\n    {\n      \"id \": \"Python for Power System Analysis toolbox (PyPSA) \",\n      \"name \": \"Python for Power System Analysis toolbox (PyPSA) \"\n    },\n    {\n      \"id \": \"Framework for Integrated Energy System Assessment \",\n      \"name \": \"Framework for Integrated Energy System Assessment \"\n    },\n    {\n      \"id \": \"Model Order Reduction for Gas and Energy Networks \",\n      \"name \": \"Model Order Reduction for Gas and Energy Networks \"\n    },\n    {\n      \"id \": \"OMEGAlpes \",\n      \"name \": \"OMEGAlpes \"\n    },\n    {\n      \"id \": \"Potsdam Integrated Assessment Modeling Framework (PIAM) \",\n      \"name \": \"Potsdam Integrated Assessment Modeling Framework (PIAM) \"\n    }\n  ]\n}\n</code></pre>"},{"location":"install-and-documentation/oeplatform-code/web-api/oekg-api/#the-sparql-endpoint-for-oekg","title":"The SPARQL endpoint for OEKG","text":"<p><code>https://openenergy-platform.org/knowledge/oekg_main</code></p> <p>Here is an example of how to query the Open Energy Knowledge Graph (OEKG) using SPARQL.</p> <pre><code>import requests\n\nsparql_endpoint = \"https://openenergy-platform.org/knowledge/oekg_main\"\nsparql_query = {\n    \"query\": \"\"\"SELECT ?s ?p ?o\n                            WHERE {\n                              ?s ?p ?o\n                            }\"\"\"\n}\n\nr = requests.get(url=sparql_endpoint, params=sparql_query)\nprint(r.json())\n</code></pre>"}]}